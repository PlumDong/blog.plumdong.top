<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马某人博客</title>
  
  <subtitle>沉迷钻研，远离浮躁</subtitle>
  <link href="https://plumdong.github.io/atom.xml" rel="self"/>
  
  <link href="https://plumdong.github.io/"/>
  <updated>2022-01-25T01:31:48.225Z</updated>
  <id>https://plumdong.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty 框架学习</title>
    <link href="https://plumdong.github.io/2022/01/20/Netty/"/>
    <id>https://plumdong.github.io/2022/01/20/Netty/</id>
    <published>2022-01-19T16:00:00.000Z</published>
    <updated>2022-01-25T01:31:48.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>netty是一个异步的，基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。</p><p><code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2-Netty的优势"><a href="#2-Netty的优势" class="headerlink" title="2. Netty的优势"></a>2. Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如</p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul>]]></content>
    
    
    <summary type="html">netty是一个异步的，基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。</summary>
    
    
    
    <category term="Netty" scheme="https://plumdong.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://plumdong.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>NIO 基础</title>
    <link href="https://plumdong.github.io/2022/01/15/NIO%E5%9F%BA%E7%A1%80/"/>
    <id>https://plumdong.github.io/2022/01/15/NIO%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-14T16:00:00.000Z</published>
    <updated>2022-01-25T01:31:59.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、三大组件"><a href="#一、三大组件" class="headerlink" title="一、三大组件"></a>一、三大组件</h1><h2 id="1、Channel-amp-Buffer"><a href="#1、Channel-amp-Buffer" class="headerlink" title="1、Channel &amp; Buffer"></a>1、<strong>Channel &amp; Buffer</strong></h2><p>channel是一个读写数据的双向通道，通过channel可以将数据读入buffer，也可以将buffer中的数据写入channel，类似于stream，但是比stream更为底层。</p><p>常见<strong>Channel</strong> ：</p><ul><li>FileChannel（文件传输通道）</li><li>DatagramChannel（UDP网络传输通道）</li><li>SocketChannel（TCP网络传输通道，专用于服务器端）</li><li>ServerSocketChannel（TCP网络传输通道）</li></ul><p>常见<strong>Buffer：</strong></p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h2 id="2、Selector"><a href="#2、Selector" class="headerlink" title="2、Selector"></a>2、<strong>Selector</strong></h2><p>selector是让一个线程同时管理多个channel，线程可以通过selector获取channel上发生的事件，不会让线程吊死在一个 channel 上，适合连数据量多但流量低的场景。</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f121.png" alt="NIO基础"></p><h1 id="二、ByteBuffer"><a href="#二、ByteBuffer" class="headerlink" title="二、ByteBuffer"></a>二、ByteBuffer</h1><h2 id="1、属性方法"><a href="#1、属性方法" class="headerlink" title="1、属性方法"></a>1、属性方法</h2><p>capacity（缓存容量） position（当前位置） limit （读取限制）</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1211.png" alt="NIO基础"></p><p>写模式下，position是写入位置，limit 等于容量capacity</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1212.png" alt="NIO基础"></p><p>flip 动作发生后，position是读取位置，limit 等于读取限制</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1213.png" alt="NIO基础"></p><p>clear 动作触发后，状态</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1214.png" alt="NIO基础"></p><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1215.png" alt="NIO基础"></p><p>ByteBuffer常用实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferAllocate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass());</span><br><span class="line"><span class="comment">//        class java.nio.HeapByteBuffer     </span></span><br><span class="line"><span class="comment">//        堆内存，读写效率较低，受GC影响</span></span><br><span class="line">        System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass());</span><br><span class="line"><span class="comment">//        class java.nio.DirectByteBuffer   </span></span><br><span class="line"><span class="comment">//        直接内存，读写效率较高（少一次数据拷贝），不受GC影响，分配效率低，可能会导致内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeapByteBuffer 和 DirectByteBuffer 关系图：</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1216.png" alt="NIO基础"></p><h2 id="2、粘包与半包"><a href="#2、粘包与半包" class="headerlink" title="2、粘包与半包"></a>2、<strong>粘包与半包</strong></h2><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因:"></a><strong>原因:</strong></h3><p>粘包：发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p>半包：接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h3><ul><li>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。<strong>注意</strong>：get(index)不会改变position的值<ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.plum.netty.nio.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer source = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">        source.put(<span class="string">&quot;hello,word\nI,m zhangsan\nHo&quot;</span>.getBytes());</span><br><span class="line">        split(source);</span><br><span class="line">        source.put(<span class="string">&quot;w are you&quot;</span>.getBytes());</span><br><span class="line">        split(source);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> length = i + <span class="number">1</span> - source.position();</span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、文件编程"><a href="#三、文件编程" class="headerlink" title="三、文件编程"></a>三、文件编程</h1><h2 id="1、FileChannel"><a href="#1、FileChannel" class="headerlink" title="1、FileChannel"></a>1、<strong>FileChannel</strong></h2><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><p><strong>获取</strong></p><p>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h2 id="2、两个Channel传输数据"><a href="#2、两个Channel传输数据" class="headerlink" title="2、两个Channel传输数据"></a>2、<strong>两个Channel传输数据</strong></h2><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;stu.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">             FileChannel inputChannel = fis.getChannel();</span><br><span class="line">             FileChannel outputChannel = fos.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 参数：inputChannel的起始位置，传输数据的大小，目的channel</span></span><br><span class="line">            <span class="comment">// 返回值为传输的数据的字节数</span></span><br><span class="line">            <span class="comment">// transferTo一次只能传输2G的数据</span></span><br><span class="line">            inputChannel.transferTo(<span class="number">0</span>, inputChannel.size(), outputChannel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;stu.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">             FileChannel inputChannel = fis.getChannel();</span><br><span class="line">             FileChannel outputChannel = fos.getChannel()) &#123;</span><br><span class="line">            <span class="keyword">long</span> size = inputChannel.size();</span><br><span class="line">            <span class="keyword">long</span> capacity = inputChannel.size();</span><br><span class="line">            <span class="comment">// 分多次传输</span></span><br><span class="line">            <span class="keyword">while</span> (capacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// transferTo返回值为传输了的字节数</span></span><br><span class="line">                capacity -= inputChannel.transferTo(size-capacity, capacity, outputChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、网络编程"><a href="#五、网络编程" class="headerlink" title="五、网络编程"></a>五、网络编程</h1><h2 id="1、阻塞"><a href="#1、阻塞" class="headerlink" title="1、阻塞"></a>1、阻塞</h2><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p><strong>服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 为服务器通道绑定端口</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 用户存放连接的集合</span></span><br><span class="line">            ArrayList&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 循环接收连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before connecting...&quot;</span>);</span><br><span class="line">                <span class="comment">// 没有连接时，会阻塞线程</span></span><br><span class="line">                SocketChannel socketChannel = server.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;after connecting...&quot;</span>);</span><br><span class="line">                channels.add(socketChannel);</span><br><span class="line">                <span class="comment">// 循环遍历集合中的连接</span></span><br><span class="line">                <span class="keyword">for</span>(SocketChannel channel : channels) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;before reading&quot;</span>);</span><br><span class="line">                    <span class="comment">// 处理通道中的数据</span></span><br><span class="line">                    <span class="comment">// 当通道中没有数据可读时，会阻塞线程</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(<span class="string">&quot;after reading&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel socketChannel = SocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            socketChannel.write(Charset.defaultCharset().encode(<span class="string">&quot;hello!&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、非阻塞"><a href="#2、非阻塞" class="headerlink" title="2、非阻塞"></a>2、非阻塞</h2><ul><li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li><li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 为服务器通道绑定端口</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 用户存放连接的集合</span></span><br><span class="line">            ArrayList&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 循环接收连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置为非阻塞模式，没有连接时返回null，不会阻塞线程</span></span><br><span class="line">                server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                SocketChannel socketChannel = server.accept();</span><br><span class="line">                <span class="comment">// 通道不为空时才将连接放入到集合中</span></span><br><span class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;after connecting...&quot;</span>);</span><br><span class="line">                    channels.add(socketChannel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 循环遍历集合中的连接</span></span><br><span class="line">                <span class="keyword">for</span>(SocketChannel channel : channels) &#123;</span><br><span class="line">                    <span class="comment">// 处理通道中的数据</span></span><br><span class="line">                    <span class="comment">// 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程</span></span><br><span class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span>(read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after reading&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、<strong>Selector</strong></h2><p><strong>多路复用</strong></p><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO 无法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入</li></ul></li><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul><p><strong>selector多路复用步骤：</strong></p><ul><li>通道设置为非阻塞模式并注册到选择器中，并设置感兴趣的事件</li><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的<strong>事件类型</strong>可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道必须设置为非阻塞模式</span></span><br><span class="line">server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将通道注册到选择器中，并设置感兴趣的实践</span></span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure></li><li>Selector监听事件：获取就绪通道个数，若没有通道就绪，线程阻塞  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞直至有绑定事件发生</span></span><br><span class="line"><span class="keyword">int</span> count = selector.select();</span><br><span class="line"><span class="comment">//阻塞直到绑定事件发生，或是超时（时间单位为 ms）</span></span><br><span class="line"><span class="keyword">int</span> count = selector.select(<span class="keyword">long</span> timeout);</span><br><span class="line"><span class="comment">//不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</span></span><br><span class="line"><span class="keyword">int</span> count = selector.selectNow();</span><br></pre></td></tr></table></figure></li><li><strong>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发。</strong></li></ul><p><strong>多路复用服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 创建选择器</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通道必须设置为非阻塞模式</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将通道注册到选择器中，并设置感兴趣的事件</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span></span><br><span class="line">                <span class="comment">// 返回值为就绪的事件个数</span></span><br><span class="line">                <span class="keyword">int</span> ready = selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;selector ready counts : &quot;</span> + ready);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用迭代器遍历事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断key的类型</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 获得key对应的channel</span></span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(<span class="string">&quot;before accepting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取连接并处理，而且是必须处理，否则需要取消</span></span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after accepting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 处理完毕后移除</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Read事件"><a href="#4、Read事件" class="headerlink" title="4、Read事件"></a>4、Read事件</h2><p>在Accept事件中，若有客户端与服务器端建立了连接，需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中Selector 中 关联read事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 创建选择器</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            <span class="comment">// 通道必须设置为非阻塞模式</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将通道注册到选择器中，并设置感兴趣的实践</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="comment">// 为serverKey设置感兴趣的事件</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span></span><br><span class="line">                <span class="comment">// 返回值为就绪的事件个数</span></span><br><span class="line">                <span class="keyword">int</span> ready = selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;selector ready counts : &quot;</span> + ready);</span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="comment">// 使用迭代器遍历事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">// 判断key的类型</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 获得key对应的channel</span></span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(<span class="string">&quot;before accepting...&quot;</span>);</span><br><span class="line">                        <span class="comment">// 获取连接</span></span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after accepting...&quot;</span>);</span><br><span class="line">                        <span class="comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中</span></span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        <span class="comment">// 处理完毕后移除</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                            System.out.println(<span class="string">&quot;before reading...&quot;</span>);</span><br><span class="line">                            <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">                            System.out.println(<span class="string">&quot;after reading...&quot;</span>);</span><br><span class="line">                            <span class="keyword">if</span> (read == -<span class="number">1</span>)&#123;</span><br><span class="line">                                key.cancel();</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                buffer.flip();</span><br><span class="line">                                ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            key.cancel();   <span class="comment">//客户端断开后，channel.read 会抛出 IOException ，并取消事件</span></span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            buffer.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理消息的边界</strong></p><p>客户端发送中文字符 “你好”，共6个字节，而服务端byteBuffer大小设置为4，不足以一次性接收所有信息，则会出现乱码情况。</p><p><img src="/myimages/e2f7696577b74c65ad876c29b182f1217.png" alt="NIO基础"></p><p>解决思路：</p><ul><li><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</li><li>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</li><li><strong>TLV 格式，即 Type 类型、Length 长度、Value 数据</strong>（也就是在消息开头<strong>用一些空间存放后面数据的长度</strong>），如HTTP请求头中的Content-Type与<strong>Content-Length</strong>。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul>  <img src="/myimages/e2f7696577b74c65ad876c29b182f1218.png" alt="NIO基础"></li></ul><h2 id="5、Write事件"><a href="#5、Write事件" class="headerlink" title="5、Write事件"></a>5、Write事件</h2><p>服务器通过Buffer向通道中写入数据时，<strong>如果通道容量小于Buffer中的数据大小，便需要分多次写入：</strong></p><ul><li>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</li><li>若Buffer中还有数据，则需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</li><li>添加写事件的相关操作key.isWritable()，对Buffer再次进行写操作。每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注。</strong></li></ul><p><strong>服务端发送数据代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    SelectionKey sckey = sc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送大量数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="comment">// 2. 返回值代表实际写入的字节数</span></span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">// 3. 判断是否有剩余内容</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 4. 关注可写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 5. 把未写完的数据挂到 sckey上</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable())&#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//清理操作</span></span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining())&#123;</span><br><span class="line">                        key.attach(<span class="keyword">null</span>);   <span class="comment">//清楚 buffer</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); <span class="comment">//注销可写事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端接收数据代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            count += sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、多线程优化"><a href="#6、多线程优化" class="headerlink" title="6、多线程优化"></a>6、多线程优化</h2><ul><li>创建一个负责处理Accept事件的Boss线程，与多个负责处理Read事件的Worker线程</li><li>Boss线程执行的操作<ul><li>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要根据标识robin去判断将任务分配给哪个Worker</li><li>register(SocketChannel socket)方法会通过同步队列完成Boss线程与Worker线程之间的通信，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</li></ul></li><li>Worker线程执行的操作<ul><li>从同步队列中获取注册任务，并处理Read事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 当前线程为Boss线程</span></span><br><span class="line">            Thread.currentThread().setName(<span class="string">&quot;Boss&quot;</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 负责轮询Accept事件的Selector</span></span><br><span class="line">            Selector boss = Selector.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.register(boss, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="comment">// 创建固定数量的Worker</span></span><br><span class="line">            Worker[] workers = <span class="keyword">new</span> Worker[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">// 用于负载均衡的原子整数</span></span><br><span class="line">            AtomicInteger robin = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">                workers[i] = <span class="keyword">new</span> Worker(<span class="string">&quot;worker-&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                boss.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = boss.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="comment">// BossSelector负责Accept事件</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 建立连接</span></span><br><span class="line">                        SocketChannel socket = server.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;connected...&quot;</span>);</span><br><span class="line">                        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">// socket注册到Worker的Selector中</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;before read...&quot;</span>);</span><br><span class="line">                        <span class="comment">// 负载均衡，轮询分配Worker</span></span><br><span class="line">                        workers[robin.getAndIncrement()% workers.length].register(socket);</span><br><span class="line">                        System.out.println(<span class="string">&quot;after read...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列，用于Boss线程与Worker线程之间的通信</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> SocketChannel socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 只启动一次</span></span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">                thread.start();</span><br><span class="line">                started = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向同步队列中添加SocketChannel的注册事件</span></span><br><span class="line">            <span class="comment">// 在Worker线程中执行注册事件</span></span><br><span class="line">            queue.add(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="comment">// 唤醒被阻塞的Selector</span></span><br><span class="line">            <span class="comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="comment">// 通过同步队列获得任务并运行</span></span><br><span class="line">                    Runnable task = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获得任务，执行注册操作</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="comment">// Worker只负责Read事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 简化处理，省略细节</span></span><br><span class="line">                            SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            socket.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、NIO与BIO"><a href="#六、NIO与BIO" class="headerlink" title="六、NIO与BIO"></a>六、<strong>NIO与BIO</strong></h1><h2 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a><strong>1、Stream与Channel</strong></h2><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></li><li>二者<strong>均为全双工</strong>，即读写可以同时进行（虽然Stream是单向流动的，但是它也是全双工的）</li></ul><h2 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a><strong>2、IO模型</strong></h2><ul><li><strong>同步</strong>：线程自己去获取结果（一个线程）<ul><li>例如：线程调用一个方法后，需要等待方法返回结果</li></ul></li><li><strong>异步</strong>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）<ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li>等待数据阶段</li><li>复制数据阶段</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"></p><p><strong>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</strong></p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a><strong>阻塞IO</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a><strong>非阻塞IO</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"></p><ul><li>用户线程<strong>在一个循环中一直调用read方法</strong>，若内核空间中还没有数据可读，立即返回，<strong>只是在等待阶段非阻塞。</strong></li><li>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><strong>多路复用</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件时，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><strong>异步IO</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h2 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a><strong>3、零拷贝</strong></h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a><strong>传统 IO 问题</strong></h3><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line">Socket socket = ...;</span><br><span class="line">socket.getOutputStream().write(buf);Copy</span><br></pre></td></tr></table></figure><p><strong>内部工作流如下</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"></p><ul><li>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU  <code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></li><li>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</li><li>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></li><li>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a><strong>NIO 优化</strong></h3><p>通过 <strong>DirectByteBuf</strong></p><ul><li>ByteBuffer.allocate(10)<ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li>ByteBuffer.<strong>allocateDirect</strong>(10)<ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a><strong>进一步优化1</strong></h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo/transferFrom</strong> 方法拷贝数据</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a><strong>进一步优化2</strong></h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png" alt="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h2 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a><strong>4、AIO</strong></h2><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li><li>异步模型需要底层操作系统（Kernel）提供支持</li><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul><p><strong>AIO示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousFileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.plum.netty.nio.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioFileChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;data.txt&quot;</span>), StandardOpenOption.READ))&#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;read begin...&quot;</span>);</span><br><span class="line">            channel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    debugAll(attachment);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.debug(<span class="string">&quot;read end...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">channel是一个读写数据的双向通道，通过channel可以将数据读入buffer，也可以将buffer中的数据写入channel，类似于stream，但是比stream更为底层。</summary>
    
    
    
    <category term="NIO" scheme="https://plumdong.github.io/categories/NIO/"/>
    
    
    <category term="NIO" scheme="https://plumdong.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Redis ZSet 底层数据结构</title>
    <link href="https://plumdong.github.io/2022/01/01/Redis%20ZSet%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://plumdong.github.io/2022/01/01/Redis%20ZSet%20%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-15T04:34:05.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Redis-常用的5种数据类型"><a href="#一、Redis-常用的5种数据类型" class="headerlink" title="一、Redis 常用的5种数据类型"></a>一、Redis 常用的5种数据类型</h1><p>1.字符串（String）<br>2.列表（List）<br>3.哈希（Hash）<br>4.集合（Set）<br>5.有序结合（ZSet）</p><h1 id="二、Zset的底层数据结构"><a href="#二、Zset的底层数据结构" class="headerlink" title="二、Zset的底层数据结构"></a>二、Zset的底层数据结构</h1><ul><li>Zset的底层使用ziplist（压缩列表）或者skiplist（跳表）</li><li>同时满足条件（1）元素数量小于128个（zet-max-ziplist-entries 128）（2）所有member的长度小于64字节（zet-max-ziplist-value 64），则使用ziplist数据结构否则使用skiplist。</li></ul><h2 id="skiplist-结构"><a href="#skiplist-结构" class="headerlink" title="skiplist 结构"></a>skiplist 结构</h2><h3 id="1-skiplist-结构体源码"><a href="#1-skiplist-结构体源码" class="headerlink" title="1.skiplist 结构体源码"></a>1.skiplist 结构体源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">  <span class="comment">//跳表</span></span><br><span class="line">  zskiplist *zsl;</span><br><span class="line">  <span class="comment">//字典</span></span><br><span class="line">  dict *dice;</span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure><h3 id="2-跳表查找原理"><a href="#2-跳表查找原理" class="headerlink" title="2.跳表查找原理"></a>2.跳表查找原理</h3><ul><li>跳表（skip List）基于链表，只不过它在链表的基础上增加了跳跃功能，实现简单插入删除查找的复杂度均为O(logN)的链表。</li><li><strong>每相邻两个节点增加一个指针，让指针指向下下个节点，所有新增加的指针连成了一个新的链表，但他包含的节点个数只有原来的一半。</strong></li><li>现在当我们想要查找数据的时候，可以先沿着这个新的链表进行查找。当碰到比待查数据大的节点时，再回到原先链表中的该节点进行查找，查找过程中，由于新增加的指针，我们不再需要与链表中每个节点进行逐个比较。需要比较的节点数约为原先的二分之一，</li><li>因此可以在新的链表上继续为每个相邻的节点增加一个指针，从而产生第三层链表，当链表足够长时，这种多层链表查找的的方式能让我们跳过很多下层节点，大大加快查找速度。</li></ul><p><img src="/myimages/2125960-20211230151034651-1061392070.png" alt="跳表"></p><h3 id="3-Zset为什么选择-skiplist"><a href="#3-Zset为什么选择-skiplist" class="headerlink" title="3. Zset为什么选择 skiplist"></a>3. Zset为什么选择 skiplist</h3><ul><li>有序和无序：skiplist和各种平衡树（AVL，红黑树）的元素是有序排列的，而hash表不是有序的，因此在hash表上只能做单个key的查找，不适合做范围查找。</li><li>范围查找：在做范围查找的时候，平衡树比skiplist操作复杂。在平衡树上找到指定范围的最小值后，还需要以中序遍历顺序继续寻找其他不超过最大值的节点，如果不对平衡树进行一定的改造，中序遍历并不容易实现。而skiplist上进行范围查找就非常简单，只需要找到最小值后对第一层链表进行若干步遍历就可以实现，</li><li>插入和删除：平衡树的插入和删除可能引起子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单迅速。</li><li>单个查找：查找单个key，skiplist和平衡树的时间复杂度都为O(logN)，大体相当：而hash表在保持较低的hash值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或者dictionary结构，大都是基于hash表实现的。</li></ul><p>总结 ：平衡树和skiplit的查找、插入、删除的速度相当，但是从算法实现难度比较skiplit比平衡树简单。因此选择 skiplist 作为Zset的底层数据结构。</p>]]></content>
    
    
    <summary type="html">Zset的底层使用ziplist（压缩列表）或者skiplist（跳表） 同时满足条件（1）元素数量小于128个（zet-max-ziplist-entries 128）（2）所有member的长度小于64字节（zet-max-ziplist-value 64），则使用ziplist数据结构否则使用skiplist。</summary>
    
    
    
    <category term="Redis" scheme="https://plumdong.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://plumdong.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入URL后发生了什么</title>
    <link href="https://plumdong.github.io/2021/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://plumdong.github.io/2021/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2021-12-25T16:00:00.000Z</published>
    <updated>2022-01-15T04:34:05.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-合成URL"><a href="#1-合成URL" class="headerlink" title="1. 合成URL"></a>1. 合成URL</h1><p>用户输入URL后浏览器根据输入的信息判断是搜索还是跳转网址，如果是搜索内容则将搜索内容 + 默认的搜索引擎组合成新的URL，如果用户数据的URL是合法网址则直接跳转至输入的URL网址。</p><h1 id="2-DNS域名解析"><a href="#2-DNS域名解析" class="headerlink" title="2. DNS域名解析"></a>2. DNS域名解析</h1><p>浏览器通过DNS域名解析服务器将输入的域名 解析 为对应服务的IP地址，这样才能访问到域名指定的服务器。</p><h3 id="本地DNS服务器查询"><a href="#本地DNS服务器查询" class="headerlink" title="本地DNS服务器查询"></a>本地DNS服务器查询</h3><p>本地DNS服务器之间递归查询，在任意一步查询到域名时就会终止递归，返回域名对应的IP地址。<br><img src="/myimages/2125960-20211222101149934-1082882416.png" alt="本地DNS解析流程"></p><h3 id="根域名服务器、顶级域名服务器、权威域名服务器"><a href="#根域名服务器、顶级域名服务器、权威域名服务器" class="headerlink" title="根域名服务器、顶级域名服务器、权威域名服务器"></a>根域名服务器、顶级域名服务器、权威域名服务器</h3><ul><li>根DNS服务器负责 返回顶级域 DNS 服务器的 IP 地址，顶级域 DNS 服务器负责 返回权威 DNS 服务器的 IP 地址，权威 DNS 服务器负责 返回相应主机的 IP 地址</li><li>如果本地的DNS服务器无法查询，则迭代到根域名服务器、顶级域名服务器、权威域名服务器 查询。</li></ul><p><img src="/myimages/2125960-20211222105352966-541624390.png"></p><h1 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h1><p>首先判断请求是否是https的，如果是则在http的基础上套上一层ssl/tls外壳，用于加密通信，每次传输的都是加密后的数据。<br><strong>TCP三次握手连接：</strong></p><ul><li>第一次握手：建立连接，客户端发送连接请求报文，将SYN位置为1，seq为X,然后客户端进入SYN_SEND状态，等待服务器的确认。</li><li>第二次握手：服务器收到SYN报文段，服务器收到客户端的SYN报文段，就知道这是一个要建立连接的请求，然后服务器也回复一个SYN的报文段(seq为y)，<br>并且附带ACK（ACK置为X+1）信息用于确认收到了第一次握手请求的信息。发送后服务端进入SYN_RECV状态。</li><li>第三次握手：客户端收到了服务器的SYN+ACK信息后，也返回一个ACK（ACK置为y+1）的确认报文。此后客户端和服务端都进入ESTABLISHED状态，完成三次握手。</li></ul><p><strong>SSL握手连接</strong></p><ul><li>第一阶段 ：客户端向服务器发送握手请求，包括所支持的TLS版本和密码组合以供服务器选择，还有一个”client random” 随机字符串</li><li>第二阶段 ：服务器对客户端进行回应，包括数据证书，服务器选择的密码组合和”server random” 随机字符串</li><li>第三阶段 ：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程具体为（1）检查数字签名（2）验证证书链（3）检查证书有效期（4）检查证书的撤回状态</li><li>第四阶段 ：客户端向服务器发送另一个随机字符串”premaster secret”(预主密钥)，这个字符串经过服务的公钥加密，只有服务器的私钥才能解密。</li><li>第五阶段 ：服务器使用私钥解密 “premaster secret” 字符串</li><li>第六阶段 ：生成共享密钥,客户端和服务器均使用 client random、server random、premaster secret，并使用相同的算法生成相同的共享密钥KEY。</li><li>第七阶段 : 客户端发送经过共享密钥 KEY 加密过的 “finished” 信号。</li><li>第八阶段 : 服务器发送经过共享密钥 KEY 加密过的 “finished” 信号。</li><li>第九阶段 ：握手完成，之后双方通信使用 共享密钥 KEY  对称加密 安全通信。</li></ul><h1 id="4-发送HTTP请求，服务器处理并返回请求"><a href="#4-发送HTTP请求，服务器处理并返回请求" class="headerlink" title="4. 发送HTTP请求，服务器处理并返回请求"></a>4. 发送HTTP请求，服务器处理并返回请求</h1><p>TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since,则验证缓存是否有效，若有效测返回状态码304，若无效则重新返回资源，状态码为200.</p><h1 id="5-关闭TCP连接"><a href="#5-关闭TCP连接" class="headerlink" title="5. 关闭TCP连接"></a>5. 关闭TCP连接</h1><p><strong>TCP四次挥手</strong></p><ul><li>第一次挥手 ：客户端（也可以是服务器端）发送一个FIN报文段给服务器，然后客户端进入FIN_WAIT_1状态</li><li>第二次挥手 ：服务器端收到了客户端发送的FIN报文段，向客户端回一个ACK确认报文，客户端进入FIN_WAIT_2状态</li><li>第三次挥手 : 服务器端向客户端发送FIN报文表示这是一个要关闭连接的请求，同事服务端进入LAST_ACL状态。</li><li>第四次挥手 ：客户端收到服务器端发送的FIN报文，向服务端发送ACK确认报文，然后客户端进入TIME_WAIT状态，服务端收到ACK确认报文后关闭连接，客户端等待1-2MS后关闭连接。</li></ul><h1 id="6-浏览器渲染"><a href="#6-浏览器渲染" class="headerlink" title="6. 浏览器渲染"></a>6. 浏览器渲染</h1><ul><li>渲染进程将 HTML 内容转换为能够读懂DOM 树结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</li></ul>]]></content>
    
    
    <summary type="html">用户输入URL后浏览器根据输入的信息判断是搜索还是跳转网址，如果是搜索内容则将搜索内容 + 默认的搜索引擎组合成新的URL，如果用户数据的URL是合法网址则直接跳转至输入的URL网址。</summary>
    
    
    
    <category term="计算机网络" scheme="https://plumdong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://plumdong.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>子串匹配—KMP算法实现</title>
    <link href="https://plumdong.github.io/2021/08/20/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://plumdong.github.io/2021/08/20/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94KMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2022-01-15T04:34:05.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>当 <code>needle</code> 是空字符串时，应当返回0。</p><h1 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h1><p>KMP算法是用于求解字符串匹配的算法，其可以把时间复杂度降为O(m+n)，进而大大提升效率。</p><p>第一步是求解next数组，是子串needle自己对自己做匹配，其定义为： t[0]~t[x] 这一段字符串，使得<strong>K-前缀恰等于K-后缀</strong>的最大的K.</p><p>因此计算next[x]则需要先知道next[x-1]，记为k，然后判断t[x-1]与t[k]是否相等，如果相等表明最长前后相等的前后缀增大了一位即next[x]=k+1，</p><p>如果不相等应该减小k，然后再次判断t[x-1]与t[k]是否相等，为了使k尽可能的大，k应该等于next[k]。</p><p>第二步就是根据所求得的next数组，与s字符数组进行匹配，如果t与s相等则两者都向前移一位，如果相等则t串的指针移至此时的指针对应的next数组的值。</p><p>整个匹配过程s字符串的指针不会后退因此只需要遍历一边s字符串等到结果提升了匹配效率。</p><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KMP kmp = <span class="keyword">new</span> KMP();</span><br><span class="line">        System.out.println(kmp.strStr(<span class="string">&quot;abcabaabaabcacb&quot;</span>, <span class="string">&quot;abaabcac&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(t);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;s.length &amp;&amp; j&lt;t.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == t[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == t.length)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] t)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[t.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = next[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (k != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i-<span class="number">1</span>] == t[k])&#123;</span><br><span class="line">                    next[i] = k+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    k = next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。当 `needle` 是空字符串时，应当返回0。</summary>
    
    
    
    <category term="算法不能丢" scheme="https://plumdong.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E4%B8%A2/"/>
    
    
    <category term="算法不能丢" scheme="https://plumdong.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E4%B8%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java八种常见算法</title>
    <link href="https://plumdong.github.io/2021/07/10/Java%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://plumdong.github.io/2021/07/10/Java%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2021-09-22T14:01:04.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、8种常见排序算法简介"><a href="#一、8种常见排序算法简介" class="headerlink" title="一、8种常见排序算法简介"></a>一、8种常见排序算法简介</h1><h2 id="1-分类图"><a href="#1-分类图" class="headerlink" title="1. 分类图"></a>1. 分类图</h2><p><img src="/myimages/image-20201230195142206.png" alt="image-20201230195142206"></p><h2 id="2-比较"><a href="#2-比较" class="headerlink" title="2. 比较"></a>2. 比较</h2><table><thead><tr><th>名称</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>稳定性</th><th>空间复杂度</th></tr></thead><tbody><tr><td>插入排序</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td></tr><tr><td>希尔排序</td><td>O(n1.3)</td><td>O(nlogn)—O(n2)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>选择排序</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n2)</td><td>不稳定</td><td>O(logn)—O(n)</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(n)</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>稳定</td><td>O(n+r)</td></tr></tbody></table><h1 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h2><p><strong>概念：</strong></p><p>插入 排序是一种简单直观且稳定的排序算法。</p><p><strong>原理：</strong></p><ol><li>把所有的元素分为两组，已排好序的和未排序的，开始时有序表只包含一个元素，无序表中包含n-1个元素。</li><li>排序过程中每次从未排序组中取出第一个元素，向已经排好序的组中插入。</li><li>倒序已经排序的元素，依次和待插入的元素进行比较，直到找到适当的位置。</li></ol><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> rt = arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rt &lt; arr[j])&#123;</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = rt;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="三、希尔排序"><a href="#三、希尔排序" class="headerlink" title="三、希尔排序"></a>三、希尔排序</h1><p>希尔排序也是一种插入排序，他是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p><p>插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。</p><h2 id="1-思路图解"><a href="#1-思路图解" class="headerlink" title="1. 思路图解"></a>1. 思路图解</h2><p><strong>基本思想：</strong> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序。随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法终止。</p><p><strong>解题过程</strong>：</p><p>（1）第一趟排序：初始增量 为：<strong>length/2 = 4</strong>，把8个数分成4组，每组单独排序</p><p><img src="/myimages/image-20210417160115290.png" alt="初始增量第一趟"></p><p>（2）第二趟，增量缩小为 2</p><p><img src="/myimages/image-20210417160907171.png" alt="image-20210417160907171"></p><p>（3）第三趟，增量缩小为 1,得到最终排序结果</p><p><img src="/myimages/image-20210417161033163.png" alt="image-20210417161033163"></p><h2 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt;  <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            Comparable tmp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; tmp.compareTo(arr[j - gap]) &lt; <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、选择排序"><a href="#四、选择排序" class="headerlink" title="四、选择排序"></a>四、选择排序</h1><h2 id="1-思路图解-1"><a href="#1-思路图解-1" class="headerlink" title="1. 思路图解"></a>1. 思路图解</h2><p><strong>基本思想：</strong>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处就是不占用额外的内存空间。</p><p><strong>算法步骤：</strong></p><p>（1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>（2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>（3）重复第（2）步，直到所有元素均排序完毕。</p><h2 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、堆排序"><a href="#五、堆排序" class="headerlink" title="五、堆排序"></a>五、堆排序</h1><h2 id="1-思路图解-2"><a href="#1-思路图解-2" class="headerlink" title="1. 思路图解"></a>1. 思路图解</h2><p><strong>基本思想：</strong></p><p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><p>（1）大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p><p>（2）小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p><strong>算法步骤：</strong></p><p>（1）创建一个堆 H[0……n-1]；</p><p>（2）把堆首（最大值）和堆尾互换；</p><p>（3）把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p><p>（4）重复步骤 2，直到堆的尺寸为 1。</p><h2 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> size = nums.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = size/<span class="number">2</span>-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">           adjust(nums, size, i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">           nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">           nums[i] = temp;</span><br><span class="line">           adjust(nums, i, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> []nums, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> maxIndex = index;</span><br><span class="line">       <span class="keyword">if</span> (l&lt;len&amp;&amp;nums[l]&gt;nums[maxIndex])maxIndex = l;</span><br><span class="line">       <span class="keyword">if</span> (r&lt;len&amp;&amp;nums[r]&gt;nums[maxIndex])maxIndex = r;</span><br><span class="line">       <span class="keyword">if</span> (maxIndex != index) &#123;</span><br><span class="line">           <span class="keyword">int</span> temp = nums[maxIndex];</span><br><span class="line">           nums[maxIndex] = nums[index];</span><br><span class="line">           nums[index] = temp;</span><br><span class="line">           adjust(nums, len, maxIndex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="六、冒泡排序"><a href="#六、冒泡排序" class="headerlink" title="六、冒泡排序"></a>六、冒泡排序</h1><h2 id="1-思路图解-3"><a href="#1-思路图解-3" class="headerlink" title="1. 思路图解"></a>1. 思路图解</h2><p><strong>基本思想：</strong>两个数比较大小，较大的数下沉，较小的数冒起来。</p><p><strong>算法步骤：</strong></p><p>（1）比较相邻的两个数据，如果第二个数小，就交换位置。</p><p>（2）从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。</p><p>（3）继续重复上述过程，依次将第2.3…n-1个最小数排好位置。</p><p><img src="/myimages/image-20210331084526757.png" alt="image-20210331084526757"></p><h2 id="2-代码实现-4"><a href="#2-代码实现-4" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = t;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。</p><p>因此设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。</p><p>这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。</p><h1 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h1><h2 id="1-思路图解-4"><a href="#1-思路图解-4" class="headerlink" title="1. 思路图解"></a>1. 思路图解</h2><p><strong>基本思想：（分治）</strong></p><p>在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p><strong>算法步骤：</strong></p><p>（1）先从数列中取出一个数作为key值；</p><p>（2）将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；</p><p>（3）对左右两个小数列重复第二步，直至各区间只有1个数。</p><h2 id="2-代码实现-5"><a href="#2-代码实现-5" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快排</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivotpos = partition(nums,low,high);</span><br><span class="line">            QuickSort(nums,low,pivotpos-<span class="number">1</span>);</span><br><span class="line">            QuickSort(nums,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot)--high;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) ++low;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">77</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.QuickSort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、归并排序"><a href="#八、归并排序" class="headerlink" title="八、归并排序"></a>八、归并排序</h1><h2 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1. 思路"></a>1. 思路</h2><p><strong>基本思想：</strong>归并排序同样是采用分治法的一个非常典型的应用。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><p>（1）自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p><p>（2）自下而上的迭代；</p><p><strong>算法步骤：</strong></p><p>（1）申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p><p>（2）设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p><p>（3）比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p><p>（4）重复步骤 3 直到某一指针达到序列尾；</p><p>（5）将另一序列剩下的所有元素直接复制到合并序列尾。</p><h2 id="2-代码实现-6"><a href="#2-代码实现-6" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">mergeSortInOrder</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> bgn,<span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = bgn, m = mid +<span class="number">1</span>, e = end;</span><br><span class="line">    <span class="keyword">int</span>[] arrs = <span class="keyword">new</span> <span class="keyword">int</span>[end - bgn + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= mid &amp;&amp; m &lt;= e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l] &lt; arr[m])&#123;</span><br><span class="line">            arrs[k++] = arr[l++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arrs[k++] = arr[m++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= mid)&#123;</span><br><span class="line">        arrs[k++] = arr[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m &lt;= e)&#123;</span><br><span class="line">        arrs[k++] = arr[m++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrs.length; i++)&#123;</span><br><span class="line">        arr[i + bgn] = arrs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bgn, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bgn &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (bgn + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(arr,bgn,mid);</span><br><span class="line">    mergeSort(arr,mid + <span class="number">1</span>, end);</span><br><span class="line">    mergeSortInOrder(arr,bgn,mid,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、基数排序"><a href="#九、基数排序" class="headerlink" title="九、基数排序"></a>九、基数排序</h1><h2 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1. 思路"></a>1. 思路</h2><p><strong>基本思想：</strong>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><strong>算法步骤：</strong></p><p>（1）将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>（2） 从最低位开始，依次进行一次排序。<br>（3） 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h2 id="2-代码实现-7"><a href="#2-代码实现-7" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bk = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">19</span>];</span><br><span class="line">        Integer max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; Math.abs(arr[i])) max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; <span class="number">0</span>) max = -max;</span><br><span class="line">        max = max.toString().length();</span><br><span class="line">        <span class="keyword">int</span> [][] bd = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">19</span>][arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; max; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = (<span class="keyword">int</span>)(arr[i] / (Math.pow(<span class="number">10</span>,k)) % <span class="number">10</span>);</span><br><span class="line">                bd[value+<span class="number">9</span>][bk[value+<span class="number">9</span>]++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> fl = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">19</span>; l++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bk[l] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; bk[l]; s++)&#123;</span><br><span class="line">                        arr[fl++] = bd[l][s];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bk = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">19</span>];</span><br><span class="line">            fl = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、8种常见排序算法简介&quot;&gt;&lt;a href=&quot;#一、8种常见排序算法简介&quot; class=&quot;headerlink&quot; title=&quot;一、8种常见排序算法简介&quot;&gt;&lt;/a&gt;一、8种常见排序算法简介&lt;/h1&gt;&lt;h2 id=&quot;1-分类图&quot;&gt;&lt;a href=&quot;#1-分类图&quot; c</summary>
      
    
    
    
    <category term="Java基础" scheme="https://plumdong.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://plumdong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中实现a==1&amp;&amp;a==2&amp;&amp;a==3</title>
    <link href="https://plumdong.github.io/2021/07/06/Java%E4%B8%AD%E5%AE%9E%E7%8E%B0a==1&amp;&amp;a==2&amp;&amp;a==3/"/>
    <id>https://plumdong.github.io/2021/07/06/Java%E4%B8%AD%E5%AE%9E%E7%8E%B0a==1&amp;&amp;a==2&amp;&amp;a==3/</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-08-26T13:42:29.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h1><ol><li><p>在Java 5中为了提高<code>Integer</code>的效率为其内部类<code>IntegerCache</code>中 添加了一个常量池<code>cache[]</code>，大小是一个字节范围是固定的 -128到127。</p></li><li><p>因此在创建<code>Integer</code>（-128到127）之间的对象时（例如<code>Integer a = 5</code>）,编译器就会调用<code>Integer.valueOf()</code>方法，直接返回常量池的对象。</p></li><li><p>所以只需要改变常量池<code>cache[]</code>中的数据即可完成<code>a==1&amp;&amp;a==2&amp;&amp;a==3</code></p></li></ol><ul><li>内部类 <code>IntegerCache</code>和<code>valueOf()</code>方法源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt;[] declaredClasses = Integer.class.getDeclaredClasses();</span><br><span class="line">            Class&lt;?&gt; integerCache = declaredClasses[<span class="number">0</span>];</span><br><span class="line">            Field f = integerCache.getDeclaredField(<span class="string">&quot;cache&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Integer[] cache = (Integer[]) f.get(integerCache);</span><br><span class="line"></span><br><span class="line">            System.out.println(cache[<span class="number">129</span>]);</span><br><span class="line">            System.out.println(cache[<span class="number">130</span>]);</span><br><span class="line">            System.out.println(cache[<span class="number">131</span>]);</span><br><span class="line"></span><br><span class="line">            cache[<span class="number">130</span>] = cache[<span class="number">129</span>];</span><br><span class="line">            cache[<span class="number">131</span>] = cache[<span class="number">129</span>];</span><br><span class="line">            Integer a = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------1-----------&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(a==(Integer)<span class="number">1</span> &amp;&amp; a==(Integer)<span class="number">2</span> &amp;&amp; a==(Integer)<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------2-----------&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(a==Integer.valueOf(<span class="number">1</span>) &amp;&amp; a==Integer.valueOf(<span class="number">2</span>) &amp;&amp; a==Integer.valueOf(<span class="number">3</span>))&#123;</span><br><span class="line">                System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------3-----------&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="keyword">new</span> Integer(<span class="number">1</span>) &amp;&amp; a==<span class="keyword">new</span> Integer(<span class="number">2</span>) &amp;&amp; a==<span class="keyword">new</span> Integer(<span class="number">3</span>))&#123;</span><br><span class="line">                System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">            System.out.println(cache[<span class="number">129</span>]);</span><br><span class="line">            System.out.println(cache[<span class="number">130</span>]);</span><br><span class="line">            System.out.println(cache[<span class="number">131</span>]);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">---------------1-----------</span><br><span class="line">true</span><br><span class="line">---------------2-----------</span><br><span class="line">true</span><br><span class="line">---------------3-----------</span><br><span class="line">---------------------------</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一、原理：利用 Integer 中的 内部类 IntegerCache</summary>
    
    
    
    <category term="Java基础" scheme="https://plumdong.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://plumdong.github.io/tags/Java/"/>
    
    <category term="花里胡哨" scheme="https://plumdong.github.io/tags/%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串-dp</title>
    <link href="https://plumdong.github.io/2021/06/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-dp/"/>
    <id>https://plumdong.github.io/2021/06/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-dp/</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-09-04T03:36:21.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><h2 id="示例-："><a href="#示例-：" class="headerlink" title="示例 ："></a>示例 ：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><h1 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h1><ul><li>动态规划说白了就是空间换时间，保存上次求解的数据，用于此次求解。</li><li>二维数组dp用于存放当前已求得的解，<code>dp[i][j] = true</code>表示 字符串<code>s</code>从第<code>i</code>个到第<code>j</code>个是一个回文子串，并且数组<code>dp[i][j]=dp[j][i]</code>关于对角线对称，所以只需要用<code>i&lt;=j</code>的上半部分。</li><li>因此初始化时二维数组的对角线初始化为<code>true</code>，且如果有两个相邻相同的元素则把<code>dp[i][i+1]</code>也置为<code>true</code>。</li><li>最后填充数组<code>dp</code>，当第<code>i</code>个元素等于第<code>j</code>个元素，即<code>charArray[i] == charArray[j]</code>时，判断前一个元素是否相同即<code>dp[i+1][j-1]</code>是否为<code>true</code>，两个条件同时满足则把当前<code>dp[i][j]</code>置为<code>true</code>并记录当前回文子串的起始位置和长度。</li></ul><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        boolean[][] dp = <span class="keyword">new</span> boolean[length][length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> ( i&lt; length <span class="number">-1</span> &amp;&amp; charArray[i] == charArray[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= length; l++) &#123;<span class="comment">//子串长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=length -l ; i++) &#123;<span class="comment">//子串起始地址</span></span><br><span class="line">                <span class="keyword">int</span> j = l + i - <span class="number">1</span>;<span class="comment">//字串结束地址</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; charArray[i] == charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    maxLen = l;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substring</span>(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">给你一个字符串 s，找到 s 中最长的回文子串。</summary>
    
    
    
    <category term="算法不能丢" scheme="https://plumdong.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E4%B8%A2/"/>
    
    
    <category term="算法不能丢" scheme="https://plumdong.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E4%B8%A2/"/>
    
  </entry>
  
  <entry>
    <title>docker中安装code-server</title>
    <link href="https://plumdong.github.io/2021/04/14/docker%E4%B8%8B%E5%AE%89%E8%A3%85code-server/"/>
    <id>https://plumdong.github.io/2021/04/14/docker%E4%B8%8B%E5%AE%89%E8%A3%85code-server/</id>
    <published>2021-04-13T16:00:00.000Z</published>
    <updated>2021-07-06T15:53:17.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker"></a>一、安装docker</h1><p>系统采用的时<code>centos8</code>，阿里云的服务器.</p><p>将下列代码保存为 <code>dockerinstall.sh</code> 并运行    <code>sh dockerinstall.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># remove old version</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all docker data </span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#  preinstall utils </span></span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># add repository</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># make cache</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># install the latest stable version of docker</span></span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># start deamon and enable auto start when power on</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># add current user </span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h1><p>//TODO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">nginx命令大全</span><br><span class="line"> 508 次浏览  发表于 2021-03-30 11:04 版权</span><br><span class="line">nginx -s reopen #重启Nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload #重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><span class="line"></span><br><span class="line">nginx -s stop #强制停止Nginx服务</span><br><span class="line"></span><br><span class="line">killall nginx #杀死所有nginx进程  </span><br><span class="line"></span><br><span class="line">nginx -s quit #优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br><span class="line"></span><br><span class="line">nginx -t #检测配置文件是否有语法错误，然后退出</span><br><span class="line"></span><br><span class="line">nginx -v #显示版本信息并退出</span><br><span class="line"></span><br><span class="line">nginx -V #显示版本和配置选项信息，然后退出</span><br><span class="line"></span><br><span class="line">nginx -t #检测配置文件是否有语法错误，然后退出</span><br><span class="line"></span><br><span class="line">nginx -T #检测配置文件是否有语法错误，转储并退出</span><br><span class="line"></span><br><span class="line">nginx -q #在检测配置文件期间屏蔽非错误信息</span><br><span class="line"></span><br><span class="line">nginx -?,-h #打开帮助信息  </span><br><span class="line"></span><br><span class="line">nginx -p prefix #设置前缀路径(默认是:/usr/share/nginx/)</span><br><span class="line"></span><br><span class="line">nginx -c filename #设置配置文件(默认是:/etc/nginx/nginx.conf)</span><br><span class="line"></span><br><span class="line">nginx -g directives #设置配置文件外的全局指令</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、安装docker&quot;&gt;&lt;a href=&quot;#一、安装docker&quot; class=&quot;headerlink&quot; title=&quot;一、安装docker&quot;&gt;&lt;/a&gt;一、安装docker&lt;/h1&gt;&lt;p&gt;系统采用的时&lt;code&gt;centos8&lt;/code&gt;，阿里云的服务器.&lt;/p</summary>
      
    
    
    
    <category term="linux" scheme="https://plumdong.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://plumdong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python3 桥接手柄和串口实现通信</title>
    <link href="https://plumdong.github.io/2021/04/14/python%20%E6%A1%A5%E6%8E%A5%E6%89%8B%E6%9F%84%E5%92%8C%E4%B8%B2%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/"/>
    <id>https://plumdong.github.io/2021/04/14/python%20%E6%A1%A5%E6%8E%A5%E6%89%8B%E6%9F%84%E5%92%8C%E4%B8%B2%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/</id>
    <published>2021-04-13T16:00:00.000Z</published>
    <updated>2022-01-24T12:37:11.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><p>需要使用游戏手柄来控制平衡小车，由于游戏手柄和平衡小车不能连接，所以使用电脑作为中介实现两者通信。</p><p>需要实现以下功能</p><ol><li>接收手柄或键盘的键值</li><li>处理接受的键值</li><li>通过串口发送指定信息给下位机</li><li>读取下位机发送的消息并显示</li></ol><span id="more"></span><h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><p>Python扩展程序包的二进制文件下载网址为：</p><p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p><p><code>pygame</code> 是一个可以读取手柄和键盘模块，我的python环境为3.7版本所以我下载的的是<code>pygame‑2.0.1‑cp37‑cp37m‑win_amd64.whl</code>。</p><p><code>pyserial</code>是一个串口通信模块，我下载的为<code>pyserial‑3.5‑py3‑none‑any.whl</code>。</p><p>下载完成后以==管理员==的身份打开命令提示符使用 pip 指令安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳转到文件下载的目录</span></span><br><span class="line">C:\WINDOWS\system32&gt; <span class="built_in">cd</span> C:\Users\Administrator\Downloads</span><br><span class="line"><span class="comment"># 使用 pip 安装 文件</span></span><br><span class="line">C:\Users\Administrator\Downloads&gt; pip install pygame‑<span class="number">2.0</span>.<span class="number">1</span>‑cp37‑cp37m‑win_amd64.whl</span><br></pre></td></tr></table></figure><p><code>pyserial</code>的啊安装也是一样的。</p><p>注意：如果是使用<code>pycharm</code> 编写的程序，会提示找不到模块，因为<code>pycharm</code> 运行环境的扩展库只扫描当前项目下的，因此我是使用VScode 编写。</p><h1 id="三、程序实现"><a href="#三、程序实现" class="headerlink" title="三、程序实现"></a>三、程序实现</h1><p> 定义通信规则：为了方便起见每次只发送一个字符，直行发送 ‘q’，加速发送 ‘s’，减速发送 ‘e’，左转发送 ‘l’，右转发送 ‘r’。</p><p>第一次调试可以打开<code>print(message)</code>查看系统获取的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 串口通信端口号</span></span><br><span class="line">portx = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 串口通信 波特率</span></span><br><span class="line">Baud = <span class="number">115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序状态</span></span><br><span class="line">state = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息</span></span><br><span class="line">message = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 串口对象</span></span><br><span class="line">ser = serial.Serial()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并选择端口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_port</span>():</span></span><br><span class="line">    <span class="keyword">global</span> portx</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在检查可用端口。。&quot;</span>)</span><br><span class="line">    port_list = <span class="built_in">list</span>(serial.tools.list_ports.comports())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(port_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无可用串口！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;序号\t名称&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(port_list)):</span><br><span class="line">            <span class="built_in">print</span>(i + <span class="number">1</span>, <span class="string">&#x27;\t&#x27;</span>, port_list[i])</span><br><span class="line"></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(port_list) != <span class="number">1</span>:</span><br><span class="line">            n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入端口序号：&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        portx = <span class="built_in">str</span>(port_list[n - <span class="number">1</span>].device)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;已选择端口:&#x27;</span>, portx)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_port</span>():</span></span><br><span class="line">    <span class="keyword">global</span> portx</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ser.baudrate = Baud</span><br><span class="line">        ser.port = portx</span><br><span class="line">        ser.<span class="built_in">open</span>()  <span class="comment"># 打开串口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        ser.close()  <span class="comment"># 关闭端口</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;端口打开失败,尝试更换端口：&#x27;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_joystick</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;连接成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    pygame.init()</span><br><span class="line">    pygame.joystick.init()</span><br><span class="line">    <span class="keyword">while</span> state:</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        message.clear()</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">                done = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.JOYBUTTONDOWN:</span><br><span class="line">                message[<span class="string">&#x27;JOYBUTTONDOWN&#x27;</span>] = event.button</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.JOYBUTTONUP:</span><br><span class="line">                message[<span class="string">&#x27;JOYBUTTONUP&#x27;</span>] = event.button</span><br><span class="line"></span><br><span class="line">        joystick_count = pygame.joystick.get_count()</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> <span class="built_in">range</span>(joystick_count):</span><br><span class="line"></span><br><span class="line">            joystick = pygame.joystick.Joystick(nums)</span><br><span class="line">            joystick.init()</span><br><span class="line"></span><br><span class="line">            axes = joystick.get_numaxes()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(axes):</span><br><span class="line">                axis = joystick.get_axis(i)</span><br><span class="line">                message[<span class="string">&#x27;axes&#x27;</span> + <span class="built_in">str</span>(i)] = <span class="built_in">int</span>(axis * <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># print(message)#打印获取的信息</span></span><br><span class="line">        <span class="keyword">if</span> message == &#123;&#125;:  <span class="comment"># 未连接</span></span><br><span class="line">            state = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;没有找到手柄&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;JOYBUTTONDOWN&#x27;</span>) == <span class="number">0</span>:  <span class="comment"># 直行</span></span><br><span class="line">            ser.write(<span class="string">b&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;直行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;JOYBUTTONDOWN&#x27;</span>) == <span class="number">1</span>:  <span class="comment"># 停车</span></span><br><span class="line">            ser.write(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;停车&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;axes5&#x27;</span>) &gt;= <span class="number">0</span>:  <span class="comment"># 加速</span></span><br><span class="line">            ser.write(<span class="string">b&#x27;s&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;加速&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;axes2&#x27;</span>) &gt;= <span class="number">0</span>:  <span class="comment"># 减速</span></span><br><span class="line">            ser.write(<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;减速&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;axes0&#x27;</span>) &lt;= -<span class="number">5</span>:  <span class="comment"># 左转</span></span><br><span class="line">            ser.write(<span class="string">b&#x27;l&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;左转&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;axes0&#x27;</span>) &gt;= <span class="number">5</span>:  <span class="comment"># 右转</span></span><br><span class="line">            ser.write(<span class="string">b&#x27;r&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;右转&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&#x27;JOYBUTTONDOWN&#x27;</span>) == <span class="number">7</span>:  <span class="comment"># 退出</span></span><br><span class="line">            state = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;退出&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ser.in_waiting:</span><br><span class="line">            <span class="built_in">print</span>(ser.read(ser.in_waiting).decode(<span class="string">&quot;gbk&quot;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> set_port() == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> open_port() == <span class="number">1</span>:</span><br><span class="line">        send_joystick()</span><br><span class="line"></span><br><span class="line">    ser.close()  <span class="comment"># 关闭端口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;按任意键退出！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">需要使用游戏手柄来控制平衡小车，由于游戏手柄和平衡小车不能连接，所以使用电脑作为中介实现两者通信。</summary>
    
    
    
    <category term="python3基础" scheme="https://plumdong.github.io/categories/python3%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="python3" scheme="https://plumdong.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习</title>
    <link href="https://plumdong.github.io/2021/03/01/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    <id>https://plumdong.github.io/2021/03/01/SpringCloud%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2022-01-15T04:34:05.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是SpringCloud"><a href="#1-什么是SpringCloud" class="headerlink" title="1.什么是SpringCloud"></a>1.什么是SpringCloud</h1><p>Spring Cloud为开发人员提供了工具，以快速构建分布式系统中的一些常见模式（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）。它们可以在任何分布式环境中正常工作，包括开发人员自己的笔记本电脑，裸机数据中心以及Cloud Foundry等托管平台。</p><span id="more"></span><h1 id="2-什么是微服务？"><a href="#2-什么是微服务？" class="headerlink" title="2.什么是微服务？"></a>2.什么是微服务？</h1><p>所谓的微服务是SOA架构下的最终产物，该架构的设计目标是为了肢解业务，使得服务能够独立运行。微服务设计原则：</p><p>1、各司其职 。</p><p>2、服务高可用和可扩展性。</p><h1 id="3-设计目标与优缺点"><a href="#3-设计目标与优缺点" class="headerlink" title="3.设计目标与优缺点"></a>3.设计目标与优缺点</h1><p>设计目标<br>协调各个微服务，简化分布式系统开发。</p><p>优缺点<br>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ol><li><p>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善</p></li><li><p>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；</p></li><li><p>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案</p></li><li><p>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</p></li><li><p>可以更精准的制定优化服务方案，提高系统的可维护性</p></li><li><p>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发</p></li><li><p>微服务可以是跨平台的，可以用任何一种语言开发</p></li><li><p>适于互联网时代，产品迭代周期更短</p></li></ol><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ol><li>微服务过多，治理成本高，不利于维护系统</li><li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</li><li>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</li></ol><h1 id="4-SpringBoot和SpringCloud的区别？"><a href="#4-SpringBoot和SpringCloud的区别？" class="headerlink" title="4.SpringBoot和SpringCloud的区别？"></a>4.SpringBoot和SpringCloud的区别？</h1><p>SpringBoot专注于快速方便的开发单个个体微服务。</p><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p><p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p><p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p><p>使用 Spring Boot 开发分布式微服务时，我们面临以下问题<br>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p><p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p><p>（3）冗余-分布式系统中的冗余问题。</p><p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p><p>（5）性能-问题 由于各种运营开销导致的性能问题。</p><p>（6）部署复杂性-Devops 技能的要求。</p><h1 id="5-服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#5-服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="5.服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>5.服务注册和发现是什么意思？Spring Cloud 如何实现？</h1><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h1 id="6-Spring-Cloud-和dubbo区别"><a href="#6-Spring-Cloud-和dubbo区别" class="headerlink" title="6.Spring Cloud 和dubbo区别?"></a>6.Spring Cloud 和dubbo区别?</h1><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p><p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p><p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p><h1 id="7-负载平衡的意义什么？"><a href="#7-负载平衡的意义什么？" class="headerlink" title="7.负载平衡的意义什么？"></a>7.负载平衡的意义什么？</h1><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>]]></content>
    
    
    <summary type="html">什么是SpringCloudSpring Cloud为开发人员提供了工具，以快速构建分布式系统中的一些常见模式（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）。它们可以在任何分布式环境中正常工作，包括开发人员自己的笔记本电脑，裸机数据中心以及Cloud Foundry等托管平台。</summary>
    
    
    
    <category term="SpringBoot" scheme="https://plumdong.github.io/categories/SpringBoot/"/>
    
    
    <category term="Spring" scheme="https://plumdong.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://plumdong.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>并发编程三大特性：可见性，有序性，原子性</title>
    <link href="https://plumdong.github.io/2021/02/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>https://plumdong.github.io/2021/02/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8E%9F%E5%AD%90%E6%80%A7/</id>
    <published>2021-02-19T16:00:00.000Z</published>
    <updated>2021-07-11T15:11:23.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程的可见性"><a href="#一、线程的可见性" class="headerlink" title="一、线程的可见性"></a>一、线程的可见性</h1><ol><li>线程在执行时会把使用的变量从内存中读取到<strong>线程的本地缓存</strong>。</li><li>线程在使用这个变量时会直接在本地缓存中读取，并不会取内存中读。</li><li>也就是说此时内存中变量的值改变时，该线程是察觉不到的，也就是导致了线程的不可见性。</li></ol><h2 id="1-线程不可见案例"><a href="#1-线程不可见案例" class="headerlink" title="1. 线程不可见案例"></a>1. 线程不可见案例</h2><p>​        新建一个线程在变量<code>runing</code>等于<code>false</code>时结束，主线程等待100毫秒（防止新线程未启动）把变量置位 <code>false</code>。</p><p>但是新线程无论等多久都不会结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> runing = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (runing)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        runing = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-解决方案：通过-volatile-修饰变量"><a href="#2-解决方案：通过-volatile-修饰变量" class="headerlink" title="2. 解决方案：通过 volatile 修饰变量"></a>2. 解决方案：通过 volatile 修饰变量</h2><p>​        volatile 关键字的作用是当变量发生改变时，其他其他线程本地缓存该变量失效，需要重新从主存中读取。因此下面程序重4中新建的线程会立即结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> runing = <span class="keyword">true</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (runing)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        runing = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、线程的有序性"><a href="#二、线程的有序性" class="headerlink" title="二、线程的有序性"></a>二、线程的有序性</h1><ol><li>处理器为了提高程序运行效率，可能会对输入代码进行优化，发生指令重排序现象。</li><li>不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是会保证程序最终执行结果和代码顺序执行的结果是一致的。</li><li>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</li></ol><h2 id="1-指令重排案例"><a href="#1-指令重排案例" class="headerlink" title="1. 指令重排案例"></a>1. 指令重排案例</h2><p>​    一般情况下程序会经常发生指令重排，但较难发生语句重排，因为一条语句由多条指令组成，较难发生多条指令重排序的情况。</p><p>​        但是下面的案例可以证明确实存在语句重排现象：程序中只有当<code>x==0 &amp;&amp; y == 0</code>时才会退出循环，如果不发生指令重排序无论两个线程如何执行都不会发生满足上述条件情况。</p><p>​        满足上述条件的情况为线程1先启动且先执行<code>x=b</code>，此时x为0，a为0，然后切换到线程2执行<code>b=1;y=a</code>（此时与这两条语句执行顺序无关），此时y也为0。满足了上述条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>;y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                a=<span class="number">1</span>;</span><br><span class="line">                x=b;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                b=<span class="number">1</span>;</span><br><span class="line">                y=a;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第 &quot;</span>+i+<span class="string">&quot; 次循环，x=&quot;</span>+x+<span class="string">&quot;;y=&quot;</span>+y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 第 949632 次循环，x=0;y=0</span></span><br></pre></td></tr></table></figure><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>​        通过volatile关键字修饰变量来保证对该变量操作时不会乱序。还可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><h1 id="三、线程原子性"><a href="#三、线程原子性" class="headerlink" title="三、线程原子性"></a>三、线程原子性</h1><p>​        即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><h2 id="1-无法保证原子性案例"><a href="#1-无法保证原子性案例" class="headerlink" title="1.无法保证原子性案例"></a>1.无法保证原子性案例</h2><ol><li>建立两个线程分别同时对变量x进行五千次加1操作，理论结果是<code>x=10000</code>,一般最终得到的结果却是小于10000的数，即便使用volatile关键字修饰也无法保证原子性。</li><li>原因是一个线程在执行<code>x++</code>时，被另一个线程打断，两个线程基于同一个旧的x的数值进行了加一操作，因此最终得到的数值会偏小。</li><li>下图是在x=100时两个线程同时对其进行加一操作引发的原子性问题。</li></ol><p><img src="/myimages/202107112252.png" alt="线程原子性验证"></p><p>原子性问题案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread tow = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        one.start();tow.start();</span><br><span class="line">        one.join();tow.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出  x=8334</span></span><br></pre></td></tr></table></figure><h2 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>​        通过synchronized关键字或者Lock锁对象锁住一块区域保证程序执行时的原子性，下面两组代码分别对其实现，最终变量x的值是固定的10000。</p><p>通过synchronized关键字方法解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Demo.class)&#123;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread tow = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        one.start();tow.start();</span><br><span class="line">        one.join();tow.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ReentrantLock可重入锁解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                    x++;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread tow = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        one.start();tow.start();</span><br><span class="line">        one.join();tow.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><ol><li><p>并发编程三大特性的重要性：并发程序想要正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p></li><li><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p></li><li><p>通过volatile关键字可以保证线程间的的可见性和有序性，但不能保证原子性。原子性可以通过synchronized和Lock保证。</p></li></ol>]]></content>
    
    
    <summary type="html">一、线程的可见性 1. 线程在执行时会把使用的变量从内存中读取到线程的本地缓存。 2. 线程在使用这个变量时会直接在本地缓存中读取，并不会取内存中读。 3. 也就是说此时内存中变量的值改变时，该线程是察觉不到的，也就是导致了线程的不可见性。</summary>
    
    
    
    <category term="Java基础" scheme="https://plumdong.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://plumdong.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://plumdong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaJUC源码解析</title>
    <link href="https://plumdong.github.io/2020/12/21/JavaJUC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://plumdong.github.io/2020/12/21/JavaJUC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-12-20T16:00:00.000Z</published>
    <updated>2021-07-11T09:27:33.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java-JUC是什么"><a href="#一、Java-JUC是什么" class="headerlink" title="一、Java JUC是什么"></a>一、Java JUC是什么</h1><p><code>JUC</code>是 <code>Java JDK1.5 </code>版本后提供多种并发容器类工具包。  全名：<code>java.util.concurrent</code></p><h2 id="1-什么是线程-进程"><a href="#1-什么是线程-进程" class="headerlink" title="1. 什么是线程/进程"></a>1. 什么是线程/进程</h2><ol><li>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li><li>线程通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，</li><li>通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</li></ol><span id="more"></span><h2 id="2-什么是并发-并行"><a href="#2-什么是并发-并行" class="headerlink" title="2. 什么是并发/并行"></a>2. 什么是并发/并行</h2><p>并发：是指多个工作交替进行，只有一条任务线</p><p>并行：是指多个工作同时进行，有多个任务线</p><h1 id="二、volatile-关键字"><a href="#二、volatile-关键字" class="headerlink" title="二、volatile 关键字"></a>二、volatile 关键字</h1><p>当多个线程共享数据时，可以保证内存中的数据可见。</p><p>相较于 synchronized 是一种轻量的同步策略</p><h1 id="三、并发举例"><a href="#三、并发举例" class="headerlink" title="三、并发举例"></a>三、并发举例</h1><h2 id="1-生产者-消费者举例"><a href="#1-生产者-消费者举例" class="headerlink" title="1. 生产者/消费者举例"></a>1. 生产者/消费者举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目： 两个生产者两个消费者，缓存区大小为1</span></span><br><span class="line"><span class="comment"> * 1. 在高内聚低耦合的前提下：线程     操作     资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        Runnable r = () -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) ticket.increment();&#125;;</span><br><span class="line">        Runnable r2 = () -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) ticket.decrease();&#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">&quot;生产者A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">&quot;生产者B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">&quot;生产者C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2, <span class="string">&quot;消费者A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2, <span class="string">&quot;消费者B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2, <span class="string">&quot;消费者C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;       <span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加一操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t现存面包数目：&quot;</span>+number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减一操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(number==<span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t现存面包数目：&quot;</span>+number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-精确顺序执行"><a href="#2-精确顺序执行" class="headerlink" title="2. 精确顺序执行"></a>2. 精确顺序执行</h2><p><code>lock</code>配和<code>Condition</code>实现精准控制线程唤醒，避免把线程全部唤醒，造成资源浪费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目： 按顺序，线程A打印5次，线程B打印10次，线程C打印15次</span></span><br><span class="line"><span class="comment"> *      循环10次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) ticket.printA5();&#125;,<span class="string">&quot;A&quot;</span>).start();;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) ticket.printB10();&#125;,<span class="string">&quot;B&quot;</span>).start();;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) ticket.printC15();&#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;       <span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;     <span class="comment">//  1：A 2：B 3：C</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">1</span>) &#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            conditionB.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB10</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">2</span>) &#123;</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            conditionC.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC15</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">3</span>) &#123;</span><br><span class="line">                conditionC.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、JUC常用类举例"><a href="#四、JUC常用类举例" class="headerlink" title="四、JUC常用类举例"></a>四、JUC常用类举例</h1><h2 id="1-CopyOnWriteArrayList"><a href="#1-CopyOnWriteArrayList" class="headerlink" title="1. CopyOnWriteArrayList"></a>1. CopyOnWriteArrayList</h2><p><code>CopyOnWriteArrayList</code>是一个线程安全队列，解决<code>ArrayList</code>线程不安全问题。</p><h3 id="1）应用举例"><a href="#1）应用举例" class="headerlink" title="1）应用举例"></a>1）应用举例</h3><p>普通<code>ArrayList</code>类不是线程安全的，因此在多线程情况下执行时会报：==<code>ConcurrentModificationException</code>并发修改异常==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(<span class="string">&quot;&quot;</span>+finalI);</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>CopyOnWriteArrayList</code>类保证多线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(<span class="string">&quot;&quot;</span>+finalI);</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）原理："><a href="#2）原理：" class="headerlink" title="2）原理："></a>2）原理：</h3><p>写时复制：每次向队列中添加元素时，即调用<code>CopyOnWriteArrayList</code>类的add()方法时。会拷贝一个新的一样的数组，然后把要添加的元素放入新的数组中，最后将新的数组替换掉原来的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-CopyOnWriteArraySet"><a href="#2-CopyOnWriteArraySet" class="headerlink" title="2. CopyOnWriteArraySet"></a>2. CopyOnWriteArraySet</h2><p><code>CopyOnWriteArraySet</code>线程安全的集合类，解决<code>HashSet</code>线程不安全问题。</p><h3 id="1）应用举例-1"><a href="#1）应用举例-1" class="headerlink" title="1）应用举例"></a>1）应用举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                set.add(<span class="string">&quot;&quot;</span>+finalI);</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）HashSet与HashMap关系"><a href="#2）HashSet与HashMap关系" class="headerlink" title="2）HashSet与HashMap关系"></a>2）HashSet与HashMap关系</h3><p><code>HashSet</code>的底层就是<code>HashMap</code>，因为<code>HashSet</code>的构造方法就是创造一个<code>HashMap</code>对象。</p><p><code>HashSet</code>和<code>HashMap</code>都是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>HashSet</code>的add方法实质是：使用<code>HashMap</code>的put方法把需要添加的元素作为键，值是一个写死的常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code>是线程安全的映射类，解决<code>HashMap</code>线程不安全问题。</p><p>用法与线程安全类一致，使用<code>Map</code>引用。</p><h2 id="4-Callable"><a href="#4-Callable" class="headerlink" title="4. Callable"></a>4. Callable</h2><p>实现<code>Callable</code>接口是第三种获得多线程的方式，相对于前两种（实现<code>Runnable</code>接口和继承Thread类）这个第三种方式可以获取线程执行后的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask futrueTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futrueTask, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        System.out.println(futrueTask.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将要执行的命令写入Callable接口中的<code>call()</code>方法，也可以指定返回值类型。</p><p>然后将线程类实例打包到<code>FutureTask</code>类，传入<code>Thread</code>类中执行。</p><ul><li><code>FutureTask.get()</code>方法可以获取线程执行的返回值，如果线程未执行结束，将会等待线程结束。</li></ul><h1 id="五、JUC常用辅助类"><a href="#五、JUC常用辅助类" class="headerlink" title="五、JUC常用辅助类"></a>五、JUC常用辅助类</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.  CountDownLatch"></a>1.  CountDownLatch</h2><p>允许一个或多个线程等待直到在其他线程中执行完成的同步辅助类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待其他线程结束后，主线程再结束.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numberThreads = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(numberThreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberThreads;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束。。。&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//等待其他线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p><code>CyclicBarrier</code>是允许一组线程全部等待彼此达到共同屏障点的辅助类。</p><p> 屏障被称为循环，因为它可以在等待的线程被释放之后重新使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numberThreads = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(numberThreads,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;全部就绪！！！！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberThreads;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t准备就绪！&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t结束！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CyclicBarrier</code>在定义时也可以不指定要执行的语句，如果指定则由最后进入的进程执行。</p><h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p><code>Semaphore</code>类用于控制并发线程数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numberThreads = <span class="number">5</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(numberThreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberThreads + <span class="number">10</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t抢到了执行权！！！&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t执行结束！！！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-ReadWriteLock"><a href="#4-ReadWriteLock" class="headerlink" title="4. ReadWriteLock"></a>4. ReadWriteLock</h2><p><code>ReadWriteLock</code>类维护一个Lock类，允许多个线程同时进行读操作，不允许多个线程同时读写和同时写操作。</p><p>可以保证进行写操作时数据的一致性.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">十个线程线程写操作，十个线程进行读操作，</span></span><br><span class="line"><span class="comment">多个线程读操作可以同时进行，写操作只能单独依次进行.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        MyMap myMap = <span class="keyword">new</span> MyMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myMap.put(finalI + <span class="string">&quot;&quot;</span>, finalI + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myMap.get(finalI + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span></span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ---写入数据&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ---写入结束&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ---读取数据&quot;</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            Object res = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ---读取结束&quot;</span> + res);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、线程池的使用"><a href="#六、线程池的使用" class="headerlink" title="六、线程池的使用"></a>六、线程池的使用</h1><h2 id="1-线程池类接口的继承实现关系图："><a href="#1-线程池类接口的继承实现关系图：" class="headerlink" title="1. 线程池类接口的继承实现关系图："></a>1. 线程池类接口的继承实现关系图：</h2><p><img src="/myimages/image-20201228215230382.png" alt="线程池类接口的继承实现关系图"></p><h2 id="2-Executors类常用方法"><a href="#2-Executors类常用方法" class="headerlink" title="2. Executors类常用方法"></a>2. Executors类常用方法</h2><p>创建线程池可以使用<code>java.util.concurrent.Executors</code>类的不同静态方法，返回不同的线程池。</p><ol><li><code>static ExecutorService newCachedThreadPool()</code> 函数返回一个根据需要创建新线程的线程池，在可用时重新使用以前的线程。 </li><li><code>static ExecutorService newFixedThreadPool(int nThreads)  </code>创建一个固定线程数量，无上限等待队列的线程池。</li><li><code>static ExecutorService newSingleThreadExecutor() </code>创建单个线程的线程池</li></ol><p>==【建议：线程池不允许使用Executors去创建】==</p><ul><li><code>FixedThreadPool</code>和<code>SingleThreadPool</code>允许的请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量请求导致OOM</li><li><code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>允许的创建线程数量为<code>Integer.MAX_VALUE</code>，可能会创建大量线程导致OOM</li><li>因此建议使用<code>ThreadPoolExecutor</code>类手动控制线程池的创建。</li></ul><h2 id="3-线程池源码解析"><a href="#3-线程池源码解析" class="headerlink" title="3.线程池源码解析"></a>3.线程池源码解析</h2><ul><li><p><code>ThreadPoolExecutor</code>类是常用的线程池实现类</p></li><li><p><code>Executors</code>类返回的线程池都是通过新建一个<code>ThreadPoolExecutor</code>返回</p></li></ul><p><code>ThreadPoolExecutor</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="1）参数说明"><a href="#1）参数说明" class="headerlink" title="1）参数说明"></a>1）参数说明</h3><ul><li><p><code>corePoolSize</code>：线程池种的线程数量，即使线程空闲也不会销毁。</p></li><li><p><code>maximumPoolSize</code>：线程池中最大的线程数，一旦超过这个数量，就会采取饱和策略</p></li><li><p><code>keepAliveTime</code>：时间，新增的线程空闲时间一旦超过这个量就会被销毁</p></li><li><p><code>unit</code>：前者的之间单位，例如秒（TimeUnit.SECONDS）</p></li><li><p><code>workQueue</code>：线程等待队列。</p></li><li><p><code>threadFactory</code>：可选参数，线程生产的工厂，可自定义产生新线程，一般使用默认值，默认值为Executors.defaultThreadFactory()</p></li><li><p><code>handler</code>：可选参数，饱和策略，当等待队列满且线程数达到最大值时需要执行的策略，默认AbortPolicy类抛出异常。</p></li></ul><h3 id="2）饱和策略"><a href="#2）饱和策略" class="headerlink" title="2）饱和策略"></a>2）饱和策略</h3><ol><li><code>AbortPolicy</code>默认饱和策略，直接抛出 java.util.concurrent.RejectedExecutionException 异常，并结束线程池，但是主线程还是会正常运行。</li><li><code>CallerRunsPolicy</code>调用者运行机制，该策略不会抛弃任务，会将任务退还给调用者执行。</li><li><code>DiscardOldestPolicy</code>抛弃队列中等待最久的任务，然后把当前任务加入队列中。</li><li><code>DiscardPolicy</code>默默抛弃无法处理的任务，不做任何处理也不抛出异常，如果允许任务丢失应选用这种策略。</li></ol><p>CallerRunsPolicy举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">4</span>,</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;\t执行！！！&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）选择最大线程数"><a href="#3）选择最大线程数" class="headerlink" title="3）选择最大线程数"></a>3）选择最大线程数</h3><ol><li><p>CPU密集型：</p><p>​    要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码</p><p>最大线程数应为CPU核心数加一，即<code>Runtime.getRuntime().availableProcessors() + 1</code></p></li><li><p>IO密集型：  </p><p>CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度。比如Web应用</p></li></ol><p>​    最大线程数应为CPU核心数乘2加一，即<code>Runtime.getRuntime().availableProcessors()*2 + 1</code></p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>在<code>java.util.function</code>包中定义了常用的函数接口，用于快速实现接口。</p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>Consumer 消费型接口</td><td>T</td><td>void</td><td>对类型为T的对象应用操作。方法为：void accept(T t)</td></tr><tr><td>Supplier 供给型接口</td><td>无</td><td>T</td><td>返回类型为T的对象。方法为：T get()</td></tr><tr><td>Function 函数型接口</td><td>T</td><td>R</td><td>对类型为T的对象应用操作，并返回结果。方法为：R apply(T t)</td></tr><tr><td>Predicate 断定型接口</td><td>T</td><td>boolean</td><td>确定类型为T的对象是否满足某约束，并返回boolean值。方法为：boolean test(T t)</td></tr></tbody></table><h2 id="1-函数型接口举例"><a href="#1-函数型接口举例" class="headerlink" title="1. 函数型接口举例"></a>1. 函数型接口举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//函数型接口,要求有输入参数和返回值，输入参数类型为String，返回值类型为Integer</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = s -&gt; Integer.parseInt(s) * <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Function 接口测试：&quot;</span> + function.apply(<span class="string">&quot;2654&quot;</span>));</span><br><span class="line"><span class="comment">//断定型接口，自定义输入参数类型，返回值参数类型始终为boolean</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = s -&gt; s==<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Predicate 接口测试：&quot;</span> + predicate.test(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="comment">//消费型接口，只有输入参数，没有返回值</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(<span class="string">&quot;Consumer 接口测试：&quot;</span> + s);</span><br><span class="line">        consumer.accept(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="comment">//供给型接口，只有返回值，没有输入参数</span></span><br><span class="line">        Supplier supplier = () -&gt; <span class="string">&quot;Supplier 接口测试&quot;</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><h2 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h2><p>函数原型：<code>Stream&lt;T&gt; filter(Predicate&lt;T&gt; predicate)</code> </p><p>需要输入一个断定型接口，用于筛选数据，返回筛选后的流。</p><h2 id="2-forEach"><a href="#2-forEach" class="headerlink" title="2. forEach"></a>2. forEach</h2><p>函数原型：<code>void forEach(Consumer&lt;T&gt; action) </code></p><p>输入一个消费型接口，无返回值。</p><h2 id="3-map"><a href="#3-map" class="headerlink" title="3.map"></a>3.map</h2><p>函数原型：<code>Stream&lt;R&gt; map(Function&lt;T, R&gt; mapper)  </code></p><p>输入一个函数式接口，对流中的数据进行操作，返回指定类型的数据。</p><h2 id="4-collect"><a href="#4-collect" class="headerlink" title="4. collect"></a>4. collect</h2><p>函数原型：<code>R collect(Collector&lt;T,A,R&gt; collector)  </code></p><p>将数据流转成指定的数据类型，返回值为指定的数据类型。</p><h2 id="5-Stream流举例："><a href="#5-Stream流举例：" class="headerlink" title="5. Stream流举例："></a>5. Stream流举例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">            list.add(i);</span><br><span class="line">        list.stream().filter(t -&gt; t%<span class="number">2</span> == <span class="number">0</span>).filter(t -&gt; t&lt;=<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = list.stream().map(x -&gt; <span class="string">&quot;x = &quot;</span> + x).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list2);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list3 = list.stream().sorted((x, y) -&gt; y-x).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><h2 id="1-ForkJoin继承关系图"><a href="#1-ForkJoin继承关系图" class="headerlink" title="1.ForkJoin继承关系图"></a>1.ForkJoin继承关系图</h2><p><img src="/myimages/image-20201230094708636.png" alt="ForkJoin继承关系图"></p><h2 id="2）应用"><a href="#2）应用" class="headerlink" title="2）应用"></a>2）应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = pool.submit(myTask);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(forkJoinTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            pool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUSY_VALUE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((begin - end) &lt;= ADJUSY_VALUE)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=begin;i&lt;=end;i++)&#123;</span><br><span class="line">                res = res + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">            MyTask myTask1 = <span class="keyword">new</span> MyTask(begin, mid);</span><br><span class="line">            MyTask myTask2 = <span class="keyword">new</span> MyTask(mid+<span class="number">1</span>, end);</span><br><span class="line">            myTask1.fork();</span><br><span class="line">            myTask1.fork();</span><br><span class="line">            res = myTask1.join() + myTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、Java-JUC是什么&quot;&gt;&lt;a href=&quot;#一、Java-JUC是什么&quot; class=&quot;headerlink&quot; title=&quot;一、Java JUC是什么&quot;&gt;&lt;/a&gt;一、Java JUC是什么&lt;/h1&gt;&lt;p&gt;&lt;code&gt;JUC&lt;/code&gt;是 &lt;code&gt;Java JDK1.5 &lt;/code&gt;版本后提供多种并发容器类工具包。  全名：&lt;code&gt;java.util.concurrent&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-什么是线程-进程&quot;&gt;&lt;a href=&quot;#1-什么是线程-进程&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是线程/进程&quot;&gt;&lt;/a&gt;1. 什么是线程/进程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。&lt;/li&gt;
&lt;li&gt;线程通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，&lt;/li&gt;
&lt;li&gt;通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://plumdong.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://plumdong.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://plumdong.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Springboot开发遇到的问题</title>
    <link href="https://plumdong.github.io/2020/12/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <id>https://plumdong.github.io/2020/12/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-08T16:00:00.000Z</published>
    <updated>2021-07-11T09:26:15.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-springboot之间版本对应问题"><a href="#一、-springboot之间版本对应问题" class="headerlink" title="一、 springboot之间版本对应问题"></a>一、 springboot之间版本对应问题</h1><span id="more"></span><ol><li>Spring Boot 不同版本间差距较大</li><li>版本号的第三位影响不大，但是版本号的第二位不同则大概率是不兼容的</li><li>因此Spring Boot 版本要慎重选择</li></ol><table><thead><tr><th>Spring Boot版本</th><th>Spring Cloud版本</th><th>Spring Cloud Alibaba版本</th></tr></thead><tbody><tr><td>2.2.6.RELEASE</td><td>Hoxton.SR9</td><td>2.2.3.RELEASE</td></tr></tbody></table><p>Spring Boot 与 Spring Cloud对应关系，详细信息网址：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></p><p>Spring Cloud 当前可用版本，详细信息网址： <a href="https://spring.io/projects/spring-cloud#learn">https://spring.io/projects/spring-cloud#learn</a></p><p>Spring Cloud Alibaba版本 与Spring Cloud 对应关系： <a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">Spring Cloud Alibaba版本说明</a></p><h1 id="二、Win下nacos-server-2-0-0启动报错java-io-IOException-java-lang-IllegalArgumentException-db-num-is-null"><a href="#二、Win下nacos-server-2-0-0启动报错java-io-IOException-java-lang-IllegalArgumentException-db-num-is-null" class="headerlink" title="二、Win下nacos-server-2.0.0启动报错java.io.IOException java.lang.IllegalArgumentException db.num is null"></a>二、Win下nacos-server-2.0.0启动报错java.io.IOException java.lang.IllegalArgumentException db.num is null</h1><h2 id="1-报错现象"><a href="#1-报错现象" class="headerlink" title="1.报错现象"></a>1.报错现象</h2><p>Win环境下启动nacos提示下列信息：</p><!--more--><p><img src="/myimages/202012092042.png" alt="在这里插入图片描述"></p><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>原因是因为nacos默认集群启动，只需要将其修改为单机启动即可</p><p>将<code>startup.cmd</code>文件以为本方式打开，大约在27行修改<code>set MODE=&quot;cluster&quot;</code>为<code>set MODE=&quot;standalone&quot;</code>。</p><p>即修改为下列形式，其中<code>rem</code>为行注释</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rem set MODE=&quot;cluster&quot;</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">MODE</span>=&quot;standalone&quot;</span><br></pre></td></tr></table></figure><h1 id="三、前后端分离项目跨域问题"><a href="#三、前后端分离项目跨域问题" class="headerlink" title="三、前后端分离项目跨域问题"></a>三、前后端分离项目跨域问题</h1><h2 id="1-报错信息："><a href="#1-报错信息：" class="headerlink" title="1. 报错信息："></a>1. 报错信息：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://localhost:8081/****&#x27; from origin &#x27;http://localhost:3000&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>所请求的资源上没有“ Access-Control-Allow-Origin”标头。 </p><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h2><ol><li>当使用ajax访问远程服务器时，出于安全的考虑，默认禁止跨域访问导致的。</li><li>也就是使用 ajax 只能请求当前ip+端口号下面的接口，一旦ip和端口号不同时就会被拦截</li></ol><p>springboot下的注解<code>@CrossOrigin</code>是允许进行跨域请求的注释.</p><h2 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3. 解决办法"></a>3. 解决办法</h2><p>对于springboot项目：</p><p>在<code>controller</code>包下文件的类名前添加<br><code>org.springframework.web.bind.annotation</code>下的<code>@CrossOrigin</code>注解</p><h1 id="四、Vue-运行报错，无法运行nuxt"><a href="#四、Vue-运行报错，无法运行nuxt" class="headerlink" title="四、Vue 运行报错，无法运行nuxt"></a>四、Vue 运行报错，无法运行nuxt</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! ylgh@1.0.0 dev: `nuxt`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the ylgh@1.0.0 dev script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br></pre></td></tr></table></figure><ol><li><p>重新下载node最新版，并在环境变量中替换当前node</p></li><li><p>删除<code>node_modules</code>和<code>package-lock.json</code>文件</p></li><li><p>重新打开cmd窗口到当前项目下，执行<code>node -v</code>查看版本是否是下载的最新版</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果是则执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">下载依赖</span></span><br><span class="line">npm -install</span><br><span class="line"><span class="meta">#</span><span class="bash">重新运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、-springboot之间版本对应问题&quot;&gt;&lt;a href=&quot;#一、-springboot之间版本对应问题&quot; class=&quot;headerlink&quot; title=&quot;一、 springboot之间版本对应问题&quot;&gt;&lt;/a&gt;一、 springboot之间版本对应问题&lt;/h1&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://plumdong.github.io/categories/SpringBoot/"/>
    
    
    <category term="Spring" scheme="https://plumdong.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://plumdong.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="https://plumdong.github.io/2020/11/22/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://plumdong.github.io/2020/11/22/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-21T16:00:00.000Z</published>
    <updated>2022-01-15T04:34:05.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-表锁（偏读）"><a href="#一、-表锁（偏读）" class="headerlink" title="一、 表锁（偏读）"></a>一、 表锁（偏读）</h1><h2 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h2><ul><li>表锁偏向MYISAM存储引擎，开销小，加锁快，无死锁，锁粒度大，发生冲突概率最高，并发低<span id="more"></span></li></ul><h2 id="2-添加表锁"><a href="#2-添加表锁" class="headerlink" title="2. 添加表锁"></a>2. 添加表锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加读锁</span><br><span class="line">lock <span class="keyword">table</span> table_name read;</span><br><span class="line"># 添加写锁</span><br><span class="line">lock <span class="keyword">table</span> table_name write;</span><br></pre></td></tr></table></figure><h2 id="2-删除表锁"><a href="#2-删除表锁" class="headerlink" title="2. 删除表锁"></a>2. 删除表锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h2 id="4-查看所有表的锁"><a href="#4-查看所有表的锁" class="headerlink" title="4. 查看所有表的锁"></a>4. 查看所有表的锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br></pre></td></tr></table></figure><h2 id="5-表锁分析命令"><a href="#5-表锁分析命令" class="headerlink" title="5. 表锁分析命令"></a>5. 表锁分析命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;table%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>Table_locks_immediate ： 表示可立即获得数据的次数</li><li>Table_locks_waited ： 表示发生锁争执的次数</li></ul><h2 id="6-读写锁的区别"><a href="#6-读写锁的区别" class="headerlink" title="6.读写锁的区别"></a>6.读写锁的区别</h2><p><code>读锁会阻塞写，但不会阻塞读。而写锁则会把读和写都堵塞</code></p><h1 id="二、-行锁（偏写）"><a href="#二、-行锁（偏写）" class="headerlink" title="二、 行锁（偏写）"></a>二、 行锁（偏写）</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>行锁偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁，锁定力度小，发生冲突的概率低，并发度高</li></ul><h2 id="2-锁定一行"><a href="#2-锁定一行" class="headerlink" title="2. 锁定一行"></a>2. 锁定一行</h2><p>for update之后相应的行会被锁定，其他操作会被阻塞，知道锁定行的会话提交commit;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span> <span class="keyword">for</span> update</span><br></pre></td></tr></table></figure><h2 id="3-行锁分析"><a href="#3-行锁分析" class="headerlink" title="3. 行锁分析"></a>3. 行锁分析</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>Innodb_row_lock_time          :  等待的总时长</li><li>Innodb_row_lock_time_avg    : 等待的平均时长</li><li>Innodb_row_lock_waits     :  等待的总次数</li></ul><h2 id="4-索引失效"><a href="#4-索引失效" class="headerlink" title="4. 索引失效"></a>4. 索引失效</h2><ul><li>索引失效时，会导致行锁升级为表锁</li></ul><h2 id="5-间隙锁"><a href="#5-间隙锁" class="headerlink" title="5. 间隙锁"></a>5. 间隙锁</h2><ul><li>当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但不存在的记录，叫做‘间隙’（GAP）</li></ul>]]></content>
    
    
    <summary type="html">一、 表锁（偏读）1.简介：表锁偏向MYISAM存储引擎，开销小，加锁快，无死锁，锁粒度大，发生冲突概率最高，并发低</summary>
    
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引优化</title>
    <link href="https://plumdong.github.io/2020/11/21/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    <id>https://plumdong.github.io/2020/11/21/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</id>
    <published>2020-11-20T16:00:00.000Z</published>
    <updated>2022-01-15T04:34:05.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、索引定义："><a href="#一、索引定义：" class="headerlink" title="一、索引定义："></a>一、索引定义：</h1><p><strong>索引是帮助数据库高效获取数据的数据结构</strong></p><p>也可以简单理解为：”排好序的快速查找数据结构”</p><span id="more"></span><p>如下就是一种可能的索引实例：</p><p><img src="/myimages/202011211309.png" alt="索引实例"></p><p>优势：</p><ul><li>提高数据检索的效率， 降低数据库的IO成本。</li><li>通过索引列对数据进行排序， 降低数据排序的成本， 降低了CPU的消耗。</li></ul><p>劣势：</p><ul><li>虽然索引大大提高了查询速度， 同时却会降低更新表的速度， 如对表进行INSERT、 UPDATE和DELETE。 因为<br>更新表时， MySQL不仅要保存数据， 还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为<br>更新所带来的键值变化后的索引信息。</li><li>实际上索引也是一张表， 该表保存了主键与索引字段， 并指向实体表的记录， 所以索引列也是要占用空间<br>的。</li></ul><h1 id="二-、创建和删除索引"><a href="#二-、创建和删除索引" class="headerlink" title="二 、创建和删除索引"></a>二 、创建和删除索引</h1><h2 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1.创建索引"></a>1.创建索引</h2><p>方法一、</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column1,column2,column3)</span><br></pre></td></tr></table></figure><p>方法二、</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">on</span> table_name(column1,column2,column3);</span><br></pre></td></tr></table></figure><p>单值索引： 即一个索引只包含单个列， 一个表可以有多个单列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column_name);</span><br></pre></td></tr></table></figure><p>唯一索引 ：索引列的值必须唯一， 但允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name(column_name);</span><br></pre></td></tr></table></figure><p>主键索引 ：<br>设定为主键后数据库会自动建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主键索引创建</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">add</span> <span class="keyword">PRIMARY</span> KEY table_name(column_name)</span><br><span class="line">主键索引删除</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY ;</span><br></pre></td></tr></table></figure><p>复合索引 ：即一个索引包含多个列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column1,column2);</span><br></pre></td></tr></table></figure><h2 id="2-删除索引"><a href="#2-删除索引" class="headerlink" title="2.删除索引"></a>2.删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX indexName <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure><h2 id="3-查看表的索引"><a href="#3-查看表的索引" class="headerlink" title="3.查看表的索引"></a>3.查看表的索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h1 id="三-、索引的创建时机"><a href="#三-、索引的创建时机" class="headerlink" title="三 、索引的创建时机"></a>三 、索引的创建时机</h1><h2 id="需要创建索引的情况"><a href="#需要创建索引的情况" class="headerlink" title="需要创建索引的情况"></a>需要创建索引的情况</h2><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>在高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li></ol><h2 id="不需要创建索引的情况"><a href="#不需要创建索引的情况" class="headerlink" title="不需要创建索引的情况"></a>不需要创建索引的情况</h2><ol><li>数据量较少，一般数据量要大于100万MySQL性能才会有明显的下降</li><li>不常用的列,若建立索引会增大空间需求，实用性不高；</li><li>数据表操作（增、删、改）远大于查询时不建议创建索引。</li><li>不要为重复过多的数据列建立索引，例如性别列</li></ol><h1 id="四、查询优化"><a href="#四、查询优化" class="headerlink" title="四、查询优化"></a>四、查询优化</h1><h2 id="1-最佳左前缀法则"><a href="#1-最佳左前缀法则" class="headerlink" title="1. 最佳左前缀法则"></a>1. 最佳左前缀法则</h2><ul><li>最佳左前缀指的是查询从索引的最左前列开始并且不跳过索引中的列。</li><li>使用复合索引， 需要遵循最佳左前缀法则， 即如果索引了多列， 要遵守最左前缀法则。 </li><li>过滤条件要使用索引必须按照索引建立时的顺序， 依次满足， 一旦跳过某个字段， 索引后面的字段都无法被使用。</li></ul><h2 id="2-不要在索引列上做任何计算"><a href="#2-不要在索引列上做任何计算" class="headerlink" title="2. 不要在索引列上做任何计算"></a>2. 不要在索引列上做任何计算</h2><ul><li>不在索引列上做任何操作（计算、 函数、 (自动 or 手动)类型转换）， 会导致索引失效而转向全表扫描。</li></ul><h2 id="3-索引列上尽量减少范围查询"><a href="#3-索引列上尽量减少范围查询" class="headerlink" title="3. 索引列上尽量减少范围查询"></a>3. 索引列上尽量减少范围查询</h2><ul><li>将可能做范围查询的字段的索引顺序放在最后</li></ul><h2 id="4-尽量使用覆盖索引"><a href="#4-尽量使用覆盖索引" class="headerlink" title="4. 尽量使用覆盖索引"></a>4. 尽量使用覆盖索引</h2><ul><li>即查询列和索引列一致或少于索引列， 不要写 select *!</li></ul><h2 id="5-不要使用不等于-或者-lt-gt"><a href="#5-不要使用不等于-或者-lt-gt" class="headerlink" title="5. 不要使用不等于(!= 或者&lt;&gt;)"></a>5. 不要使用不等于(!= 或者&lt;&gt;)</h2><ul><li>mysql 在使用不等于(!= 或者&lt;&gt;)时， 有时会无法使用索引会导致全表扫描</li></ul><h2 id="6-使用-is-null-而非-is-not-null"><a href="#6-使用-is-null-而非-is-not-null" class="headerlink" title="6. 使用 is null  而非 is not null"></a>6. 使用 is null  而非 is not null</h2><ul><li>因为is not null 用不到索引， is null 可以用到索引。</li></ul><h2 id="8-like-的前后模糊匹配"><a href="#8-like-的前后模糊匹配" class="headerlink" title="8. like 的前后模糊匹配"></a>8. like 的前后模糊匹配</h2><ul><li>前缀不能出现模糊匹配！</li><li>like 条件匹配时’chen%’和’chen%j%’可以用到索引,like ‘%chen’和’%chen%’用不到索引</li><li>如果非要写’%chen%’要尽量使用覆盖索引，即查询列与索引列一致或少于索引列</li></ul><h2 id="9-减少使用-or"><a href="#9-减少使用-or" class="headerlink" title="9. 减少使用 or"></a>9. 减少使用 or</h2><ul><li>使用 union all 或者 union 来替代：</li></ul><h1 id="五、排序优化"><a href="#五、排序优化" class="headerlink" title="五、排序优化"></a>五、排序优化</h1><h2 id="1-尽量在索引列上完成排序"><a href="#1-尽量在索引列上完成排序" class="headerlink" title="1. 尽量在索引列上完成排序"></a>1. 尽量在索引列上完成排序</h2><h2 id="2-避免使用select-，只查询需要的列"><a href="#2-避免使用select-，只查询需要的列" class="headerlink" title="2. 避免使用select *，只查询需要的列"></a>2. 避免使用select *，只查询需要的列</h2><h2 id="3-最佳左前缀法则"><a href="#3-最佳左前缀法则" class="headerlink" title="3. 最佳左前缀法则"></a>3. 最佳左前缀法则</h2><ul><li>若最索引在where种变为常量，则可变为次前缀<h2 id="4-增大MySQL参数sort-buffer-size，增大排序缓冲区"><a href="#4-增大MySQL参数sort-buffer-size，增大排序缓冲区" class="headerlink" title="4. 增大MySQL参数sort_buffer_size，增大排序缓冲区"></a>4. 增大MySQL参数sort_buffer_size，增大排序缓冲区</h2></li></ul><h1 id="六、-分组优化"><a href="#六、-分组优化" class="headerlink" title="六、 分组优化"></a>六、 分组优化</h1><h2 id="1-group-by实质是先排序后分组，遵循最佳左前缀"><a href="#1-group-by实质是先排序后分组，遵循最佳左前缀" class="headerlink" title="1. group by实质是先排序后分组，遵循最佳左前缀"></a>1. group by实质是先排序后分组，遵循最佳左前缀</h2><h2 id="2-where高于having，能在where中限定的条件不要去having中限定"><a href="#2-where高于having，能在where中限定的条件不要去having中限定" class="headerlink" title="2. where高于having，能在where中限定的条件不要去having中限定"></a>2. where高于having，能在where中限定的条件不要去having中限定</h2>]]></content>
    
    
    <summary type="html">一、索引定义：索引是帮助数据库高效获取数据的数据结构也可以简单理解为：&quot;排好序的快速查找数据结构&quot;</summary>
    
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>鸡蛋掉落——动态规划</title>
    <link href="https://plumdong.github.io/2020/11/21/%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://plumdong.github.io/2020/11/21/%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-11-20T16:00:00.000Z</published>
    <updated>2021-07-11T09:25:05.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。1 &lt;= K &lt;= 100</p><p>1 &lt;= N &lt;= 10000</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><span id="more"></span><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p>输入：K = 1, N = 2</p><p>输出：2</p><p>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</p><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p>输入：K = 2, N = 6</p><p>输出：3</p><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><p>输入：K = 3, N = 14</p><p>输出：4</p><h1 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h1><p>题目中并没有说鸡蛋什么时候会碎，但是需要知道的是鸡蛋一定是恰好摔碎再最坏情况下的那层楼，即鸡蛋破碎一定发生在搜索区间穷尽时</p><h2 id="思路一、"><a href="#思路一、" class="headerlink" title="思路一、"></a>思路一、</h2><ol><li><p>首先考虑如果只有一个鸡蛋的情况下，我们就必须从1楼开始到N楼一层一层的尝试，也就是需要N次。</p></li><li><p>然后假设有K个鸡蛋，第一个鸡蛋开始从X层楼向下丢，就会分为碎和不碎两种情况：</p></li><li><p>第一种情况：鸡蛋没碎就会剩余K个蛋，N-X层楼，然后递归求解</p></li><li><p>第二种情况：鸡蛋碎了就会剩余K-1个蛋，X-1层楼，然后递归求解</p></li><li><p>最后求的两种解取最大值加一就等到了K个鸡蛋N层楼需要移动的次数</p></li><li><p>定义二维数组P存放K个鸡蛋N层楼所有情况的最优解，其中：<code> P(K,N)= 1+ min(max(dp(K−1,X−1),dp(K,N−X)))，1≤X≤N</code></p></li><li><p>此种解法时间复杂度O(KN^2)，空间复杂度为O(KN)，都非常高</p></li></ol><h2 id="思路二、"><a href="#思路二、" class="headerlink" title="思路二、"></a>思路二、</h2><ol><li><p>首先考虑如果只能移动一次的话，无论你有多少个鸡蛋，你最多只能确定1层楼</p></li><li><p>假设有K个鸡蛋，需要至少移动T次才能找N层楼的解，因此要找到P[K][T]&gt;=N时最小的T</p></li><li><p>同理用动态规划找满足条件的T，每次也要分为鸡蛋碎和不碎两种可能</p></li><li><p>第一种情况：鸡蛋没碎，那么对应的是 P[K,T−1]，也就是说在这一层的上方可以有 P[K,T-1]层；+</p></li><li><p>第二种情况：鸡蛋碎了，那么对应的是 P[K−1,T−1]，也就是说在这一层的下方可以有 P[T-1，K - 1]层。</p></li><li><p>定义二维数组P需要T次移动和有K个鸡蛋时能证明最大的层数为<code>p[K][T] = 1 + p[K - 1][T - 1] + p[K][T-1];</code></p></li><li><p>时间复杂度O(KN)，空间复杂度为O(KN)</p></li></ol><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><h2 id="思路一、-1"><a href="#思路一、-1" class="headerlink" title="思路一、"></a>思路一、</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,n;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(k, n);</span><br><span class="line">    cout&lt;&lt;p[k][n]&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=k;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;p[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">        p[k][n] = n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p[k][n] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(<span class="built_in">backtrack</span>(k<span class="number">-1</span>, x<span class="number">-1</span>), <span class="built_in">backtrack</span>(k, n-x)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p[k][n] = res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[k][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路二、-1"><a href="#思路二、-1" class="headerlink" title="思路二、"></a>思路二、</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,n;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        p[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">2</span>;t&lt;=n;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            p[j][t] = <span class="number">1</span> + p[j - <span class="number">1</span>][t - <span class="number">1</span>] + p[j][t<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[k][t] &gt;= n) &#123;</span><br><span class="line">            res = t;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=res;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=k;j++)</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;p[j][i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h1&gt;&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。1 &amp;lt;= K &amp;lt;= 100&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= N &amp;lt;= 10000&lt;/p&gt;
&lt;p&gt;每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。&lt;/p&gt;
&lt;p&gt;你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;/p&gt;
&lt;p&gt;每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。&lt;/p&gt;
&lt;p&gt;你的目标是确切地知道 F 的值是多少。&lt;/p&gt;
&lt;p&gt;无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？&lt;/p&gt;</summary>
    
    
    
    <category term="算法不能丢" scheme="https://plumdong.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E4%B8%A2/"/>
    
    
    <category term="C++" scheme="https://plumdong.github.io/tags/C/"/>
    
    <category term="算法不能丢" scheme="https://plumdong.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E4%B8%A2/"/>
    
  </entry>
  
  <entry>
    <title>MySQL七种JOIN理论</title>
    <link href="https://plumdong.github.io/2020/11/19/MySQL%E4%B8%83%E7%A7%8DJOIN%E7%90%86%E8%AE%BA/"/>
    <id>https://plumdong.github.io/2020/11/19/MySQL%E4%B8%83%E7%A7%8DJOIN%E7%90%86%E8%AE%BA/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2021-07-11T09:27:53.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、读取JOIN语句过程"><a href="#一、读取JOIN语句过程" class="headerlink" title="一、读取JOIN语句过程"></a>一、读取JOIN语句过程</h1><p><img src="/myimages/202011191022.png" alt="JOIN图"></p><span id="more"></span><h1 id="二、JOIN查询方式图"><a href="#二、JOIN查询方式图" class="headerlink" title="二、JOIN查询方式图"></a>二、JOIN查询方式图</h1><p><img src="/myimages/202011190913.png" alt="JOIN图"></p><h1 id="三、JOIN查询语句示例"><a href="#三、JOIN查询语句示例" class="headerlink" title="三、JOIN查询语句示例"></a>三、JOIN查询语句示例</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tbl_emp;</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tbl_emp`  (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`deptId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`) ,</span><br><span class="line">KEY `fk_dept_id`(`deptId`)</span><br><span class="line">)ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8;</span><br><span class="line"> <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tbl_dept;</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tbl_dept`  (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`deptName` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `locAdd` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_dept(deptName,locAdd) <span class="keyword">VALUES</span>(<span class="string">&#x27;RD&#x27;</span>,<span class="number">11</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_dept(deptName,locAdd) <span class="keyword">VALUES</span>(<span class="string">&#x27;HR&#x27;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_dept(deptName,locAdd) <span class="keyword">VALUES</span>(<span class="string">&#x27;MK&#x27;</span>,<span class="number">13</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_dept(deptName,locAdd) <span class="keyword">VALUES</span>(<span class="string">&#x27;MIS&#x27;</span>,<span class="number">14</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_dept(deptName,locAdd) <span class="keyword">VALUES</span>(<span class="string">&#x27;FD&#x27;</span>,<span class="number">15</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_dept(deptName,locAdd) <span class="keyword">VALUES</span>(<span class="string">&#x27;BSR&#x27;</span>,<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME ,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;z3&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;z4&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME ,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;z5&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME ,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;w5&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;w6&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;s7&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;s8&#x27;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;s9&#x27;</span>,<span class="number">5</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_emp(NAME,deptId) <span class="keyword">VALUES</span>(<span class="string">&#x27;wgk&#x27;</span>,<span class="number">999</span>);</span><br></pre></td></tr></table></figure><h2 id="1-示例一"><a href="#1-示例一" class="headerlink" title="1. 示例一"></a>1. 示例一</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">inner</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p>查询返回两个表共有的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+----+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+----+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> z3   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> z4   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> z5   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> w5   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> w6   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> s7   <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> MK       <span class="operator">|</span> <span class="number">13</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> s8   <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> MIS      <span class="operator">|</span> <span class="number">14</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> s9   <span class="operator">|</span>      <span class="number">5</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> FD       <span class="operator">|</span> <span class="number">15</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+----+----------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="2-示例二"><a href="#2-示例二" class="headerlink" title="2. 示例二"></a>2. 示例二</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">left</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p>查询返回 tbl_emp 所有记录和两个表共有的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id   <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> z3   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> z4   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> z5   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> w5   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> w6   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> s7   <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> MK       <span class="operator">|</span> <span class="number">13</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> s8   <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> MIS      <span class="operator">|</span> <span class="number">14</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> s9   <span class="operator">|</span>      <span class="number">5</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> FD       <span class="operator">|</span> <span class="number">15</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> wgk  <span class="operator">|</span>    <span class="number">999</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+------+----------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="3-示例三"><a href="#3-示例三" class="headerlink" title="3. 示例三"></a>3. 示例三</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">right</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p>查询返回 tbl_dept 所有记录和两个表共有的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+----+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+----+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> z3   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> z4   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> z5   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> w5   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> w6   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> s7   <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> MK       <span class="operator">|</span> <span class="number">13</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span> s8   <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> MIS      <span class="operator">|</span> <span class="number">14</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">8</span> <span class="operator">|</span> s9   <span class="operator">|</span>      <span class="number">5</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> FD       <span class="operator">|</span> <span class="number">15</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> BSR      <span class="operator">|</span> <span class="number">250</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+----+----------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="4-示例四"><a href="#4-示例四" class="headerlink" title="4. 示例四"></a>4. 示例四</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">left</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>查询返回 tbl_emp 独有的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id   <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> wgk  <span class="operator">|</span>    <span class="number">999</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+------+----------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="5-示例五"><a href="#5-示例五" class="headerlink" title="5. 示例五"></a>5. 示例五</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">right</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">where</span> a.deptId <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>查询返回 tbl_dept 独有的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+----+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+----+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> BSR      <span class="operator">|</span> <span class="number">250</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+----+----------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="6-示例六"><a href="#6-示例六" class="headerlink" title="6. 示例六"></a>6. 示例六</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">left</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id </span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">right</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p>查询返回 两个表全部 的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id   <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> z3   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> z4   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> z5   <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> RD       <span class="operator">|</span> <span class="number">11</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> w5   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> w6   <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> HR       <span class="operator">|</span> <span class="number">12</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> s7   <span class="operator">|</span>      <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> MK       <span class="operator">|</span> <span class="number">13</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span> s8   <span class="operator">|</span>      <span class="number">4</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> MIS      <span class="operator">|</span> <span class="number">14</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">8</span> <span class="operator">|</span> s9   <span class="operator">|</span>      <span class="number">5</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> FD       <span class="operator">|</span> <span class="number">15</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">9</span> <span class="operator">|</span> wgk  <span class="operator">|</span>    <span class="number">999</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> BSR      <span class="operator">|</span> <span class="number">250</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+------+----------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="7-示例七"><a href="#7-示例七" class="headerlink" title="7. 示例七"></a>7. 示例七</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">left</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">WHERE</span>  b.id <span class="keyword">is</span> <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_emp a <span class="keyword">right</span> <span class="keyword">join</span> tbl_dept b <span class="keyword">on</span> a.deptId <span class="operator">=</span> b.id <span class="keyword">WHERE</span> a.deptId <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>查询返回 两个表各自独有 的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> id   <span class="operator">|</span> deptName <span class="operator">|</span> locAdd <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">9</span> <span class="operator">|</span> wgk  <span class="operator">|</span>    <span class="number">999</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> BSR      <span class="operator">|</span> <span class="number">250</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------+------+----------+--------+</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、读取JOIN语句过程&quot;&gt;&lt;a href=&quot;#一、读取JOIN语句过程&quot; class=&quot;headerlink&quot; title=&quot;一、读取JOIN语句过程&quot;&gt;&lt;/a&gt;一、读取JOIN语句过程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/myimages/202011191022.png&quot; alt=&quot;JOIN图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的 EXPLAIN 使用</title>
    <link href="https://plumdong.github.io/2020/11/19/MySQL%E7%9A%84Explain%E4%BD%BF%E7%94%A8/"/>
    <id>https://plumdong.github.io/2020/11/19/MySQL%E7%9A%84Explain%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2021-07-11T09:27:45.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、EXPLAIN简介"><a href="#一、EXPLAIN简介" class="headerlink" title="一、EXPLAIN简介"></a>一、EXPLAIN简介</h1><p>使用 EXPLAIN 关键字可以模拟优化器执行sql查询语句，从而知道MySQL是如何处理你的sql语句，分析查询语句或者表结构的性能瓶颈.</p><span id="more"></span><h1 id="二、EXPLAIN用法"><a href="#二、EXPLAIN用法" class="headerlink" title="二、EXPLAIN用法"></a>二、EXPLAIN用法</h1><p>EXPLAIN + SQL语句</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_emp;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tbl_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">9</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>其中五个比较重要的字段分别为：id、type、key、rows、Extra</p><h2 id="ID字段："><a href="#ID字段：" class="headerlink" title="ID字段："></a>ID字段：</h2><p>表示执行的顺序，ID字段分为两种情况：</p><ol><li>相同：按照顺序从上到下执行</li><li>不同：按照ID字段的大小，从大到小执行</li><li>既有相同也有不同：把id相同的认为是一组，从上往下顺序执行。 在所有组中首先执行ID数值大的。其中：DERIVED = 衍生</li></ol><p>注：<br><strong>id 号每个号码， 表示一趟独立的查询。 一个 sql 的查询趟数越少越好。</strong></p><h2 id="SELECT-TYPE字段："><a href="#SELECT-TYPE字段：" class="headerlink" title="SELECT_TYPE字段："></a>SELECT_TYPE字段：</h2><p>表示查询类型，主要分为6种：</p><ol><li><code>SIMPLE</code>  普通查询：简单的select查询，查询中不包含子查询或者union</li><li><code>PRIMARY</code>  联合查询：查询中若包含任何复杂的子部分，最外层查询则被标记为联合查询</li><li><code>SUBQUERY</code> 子查询：在 select 或 where 列表中包含的子查询</li><li><code>DERIVED</code> 嵌套查询：在from列表种包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放到临时表中</li><li><code>UNION</code>   连接查询：若查询语句中第二个 select 出现在 UNION 标识符之后，则被标记为 UNION ，若 UNION 包含在from子句中，则外层 select 将被标记为：DERIVED</li><li><code>UNION RESULT</code> 从 UNION 表中获取结果的 select</li></ol><h2 id="TABLE字段："><a href="#TABLE字段：" class="headerlink" title="TABLE字段："></a>TABLE字段：</h2><p>表示与哪一张表相关</p><h2 id="TYPE字段："><a href="#TYPE字段：" class="headerlink" title="TYPE字段："></a>TYPE字段：</h2><p>显示访问类型，是一个较为重要的指标，结果值从好到坏依次为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL </span><br></pre></td></tr></table></figure><p>一般情况下查询至少达到 <code>range</code> 级别，最好能达到 <code>ref</code> </p><ol><li>system ：表只有一行记录，平时不会出现，可以忽略</li><li>const ：表示通过一次索引就能找到</li><li>eq_ref ： 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配</li><li>ref ： 非唯一性索引扫描，返回匹配某个单独值的所有行，属于查找和扫描的混合体</li><li>range ： 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引</li><li>index ： 与ALL区别是只遍历索引树</li><li>ALL ： 全表扫描</li></ol><h2 id="POSSIBLE-KEYS和KEY字段："><a href="#POSSIBLE-KEYS和KEY字段：" class="headerlink" title="POSSIBLE_KEYS和KEY字段："></a>POSSIBLE_KEYS和KEY字段：</h2><p>possible_keys</p><ul><li>显示可能应用在这张表种的索引，一个或多个。</li><li>查询涉及到的字段上若存在索引，则索引将被列出，<code>但不一定被查询实际使用</code></li></ul><p>key</p><ul><li>实际使用的索引，如果为null则证明没有使用索引</li><li>查询中若使用了覆盖索引，则该索引仅出现在key列表中</li><li>查询使用的索引时以<code>key</code>列为准</li></ul><h2 id="key-len-字段："><a href="#key-len-字段：" class="headerlink" title="key_len 字段："></a>key_len 字段：</h2><ul><li>表示索引种使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精度的情况下，长度越短越好</li><li>key_len 显示的值为索引字段的最大可能长度，<code>并非实际使用长度</code>，即key_len是根据表定义计算而得，不是通过表内检索出的</li></ul><h2 id="ref字段："><a href="#ref字段：" class="headerlink" title="ref字段："></a>ref字段：</h2><p>显示索引的哪一列被使用了，可能是一个常数，哪些列或者常量被用于查找索引列的值</p><h2 id="rows字段："><a href="#rows字段：" class="headerlink" title="rows字段："></a>rows字段：</h2><p>显示表有多少行被优化器查询，是一个衡量索引优化的重要指标，值越小越好</p><h2 id="Extra-字段："><a href="#Extra-字段：" class="headerlink" title="Extra 字段："></a>Extra 字段：</h2><p>包含不适合在其他列种显示但十分重要的额外信息，其可能的信息</p><ol><li><p><code>Using filesort</code> ： MySQL无法利用索引完成排序操作，需要自己重新从对数据进行排序</p></li><li><p><code>Using temporary</code> ： MySQL无法利用索引完成分组，需要创建临时表来完成分组</p></li><li><p><code>Using index</code> ： 查询的列被所建的索引覆盖，只需要从索引中获取数据，不必读数据行，查询到的数据叫覆盖索引，效率较高</p></li><li><p>Using where ：表明使用了where过滤</p></li><li><p>Using join buff ：表明 join 次数过多，应调大缓冲区的join buff</p></li><li><p>impossible where：表明where子句的值总是false</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、EXPLAIN简介&quot;&gt;&lt;a href=&quot;#一、EXPLAIN简介&quot; class=&quot;headerlink&quot; title=&quot;一、EXPLAIN简介&quot;&gt;&lt;/a&gt;一、EXPLAIN简介&lt;/h1&gt;&lt;p&gt;使用 EXPLAIN 关键字可以模拟优化器执行sql查询语句，从而知道MySQL是如何处理你的sql语句，分析查询语句或者表结构的性能瓶颈.&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://plumdong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>linux(centos7)安装MySQL5.7</title>
    <link href="https://plumdong.github.io/2020/11/17/linux(centos7)%E5%AE%89%E8%A3%85MySQL5.7/"/>
    <id>https://plumdong.github.io/2020/11/17/linux(centos7)%E5%AE%89%E8%A3%85MySQL5.7/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2020-11-18T10:12:58.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、下载MySQL"><a href="#一、下载MySQL" class="headerlink" title="一、下载MySQL"></a>一、下载MySQL</h1><p>首先进入opt文件夹下，下载mysql-5.7.27的安装包，下载过程可能比较慢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cd /opt</span><br><span class="line">[root@localhost opt]# wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.27-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>其他版本可去官网下载：<br><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><span id="more"></span><h1 id="二、解压-MySQL-并配置"><a href="#二、解压-MySQL-并配置" class="headerlink" title="二、解压 MySQL 并配置"></a>二、解压 MySQL 并配置</h1><h2 id="1-解压MySQL"><a href="#1-解压MySQL" class="headerlink" title="1.解压MySQL"></a>1.解压MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# tar -zvxf mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="2-移动解压好的文件夹"><a href="#2-移动解压好的文件夹" class="headerlink" title="2.移动解压好的文件夹"></a>2.移动解压好的文件夹</h2><p>保证 目录 /usr/local 下无mysql重名的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# mv mysql-5.7.24-linux-glibc2.12-x86_64 /usr/local/mysql</span><br><span class="line">[root@localhost opt]# cd /usr/local/mysql</span><br></pre></td></tr></table></figure><h2 id="3-在-usr-local-mysql目录下创建data目录"><a href="#3-在-usr-local-mysql目录下创建data目录" class="headerlink" title="3.在/usr/local/mysql目录下创建data目录"></a>3.在/usr/local/mysql目录下创建data目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# mkdir data</span><br></pre></td></tr></table></figure><h2 id="4-修改MySQL配置文件"><a href="#4-修改MySQL配置文件" class="headerlink" title="4.修改MySQL配置文件"></a>4.修改MySQL配置文件</h2><p>打开 <code>/etc/my.cnf</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p>将其内容改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"></span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">datadir = /usr/local/mysql/data</span><br><span class="line">port = 3306</span><br><span class="line">socket = /var/lib/mysql/mysql.sock</span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line">log-error = /usr/local/mysql/data/mysqld.log</span><br><span class="line">pid-file = /usr/local/mysql/data/mysqld.pid</span><br></pre></td></tr></table></figure><h2 id="5-创建mysql用户组"><a href="#5-创建mysql用户组" class="headerlink" title="5.创建mysql用户组"></a>5.创建mysql用户组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# chown -R mysql:mysql /usr/local/mysql</span><br><span class="line">[root@localhost mysql]# chmod -R 755 /usr/local/mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-安装并初始化mysql"><a href="#6-安装并初始化mysql" class="headerlink" title="6.安装并初始化mysql"></a>6.安装并初始化mysql</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# bin/mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql</span><br></pre></td></tr></table></figure><p>查看初始密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# cat /usr/local/mysql/data/mysqld.log</span><br></pre></td></tr></table></figure><p>执行后会输出日志，日志最后一行尾部就是初始密码<br><img src="/myimages/202011181628.png" alt="MySQL日志"></p><h2 id="7-添加软连接"><a href="#7-添加软连接" class="headerlink" title="7.添加软连接"></a>7.添加软连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]#  ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql </span><br><span class="line">[root@localhost mysql]#  ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql</span><br></pre></td></tr></table></figure><h2 id="8-启动MySQL"><a href="#8-启动MySQL" class="headerlink" title="8.启动MySQL"></a>8.启动MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]#  service mysql start</span><br></pre></td></tr></table></figure><p>查看MySQL进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ps -ef | grep mysql</span><br></pre></td></tr></table></figure><h2 id="9、登录mysql，修改密码"><a href="#9、登录mysql，修改密码" class="headerlink" title="9、登录mysql，修改密码"></a>9、登录mysql，修改密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]#  mysql -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码为 MySQL日志 中的初始密码</span></span><br></pre></td></tr></table></figure><p>将密码改为 123456，也可以改为别的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for root@localhost = password(&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure><h2 id="10、远程连接"><a href="#10、远程连接" class="headerlink" title="10、远程连接"></a>10、远程连接</h2><p>user.Host=’%’表示任何主机，User=’root’表示使用 root 用户访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash">use mysql;</span></span><br><span class="line"><span class="meta">msyql&gt;</span><span class="bash">update user <span class="built_in">set</span> user.Host=<span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user.User=<span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash">flush privileges;</span></span><br></pre></td></tr></table></figure><p>重启mysql生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# service mysql restart</span><br></pre></td></tr></table></figure><p>打开防火墙3306端口，查看端口是否开放</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有 3306/tcp 则证明3306端口没有开放</span></span><br></pre></td></tr></table></figure><p>打开3306端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> success</span></span><br></pre></td></tr></table></figure><p>重启防火墙生效设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> success</span></span><br></pre></td></tr></table></figure><p>下载 mysql workbench 可视化工具，就可以远程连接到服务器的MySQL进行配置</p><p>下载地址：<a href="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/</a></p><h2 id="11、开机启动"><a href="#11、开机启动" class="headerlink" title="11、开机启动"></a>11、开机启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost init.d]#  cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">[root@localhost init.d]# chkconfig --add mysqld</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、下载MySQL&quot;&gt;&lt;a href=&quot;#一、下载MySQL&quot; class=&quot;headerlink&quot; title=&quot;一、下载MySQL&quot;&gt;&lt;/a&gt;一、下载MySQL&lt;/h1&gt;&lt;p&gt;首先进入opt文件夹下，下载mysql-5.7.27的安装包，下载过程可能比较慢&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost /]# cd /opt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost opt]# wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.27-linux-glibc2.12-x86_64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其他版本可去官网下载：&lt;br&gt;&lt;a href=&quot;https://downloads.mysql.com/archives/community/&quot;&gt;https://downloads.mysql.com/archives/community/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://plumdong.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://plumdong.github.io/tags/linux/"/>
    
    <category term="MySQL" scheme="https://plumdong.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
